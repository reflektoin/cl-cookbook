Common Lisp has a complete and flexible type system and corresponding
tools to inspect, check and manipulate types. It allows creating
custom types, adding type declarations to variables and functions and
thus to get compile-time warnings and errors.

** Values Have Types, Not Variables
   :PROPERTIES:
   :CUSTOM_ID: values-have-types-not-variables
   :END:

Being different from some languages such as C/C++, variables in Lisp are just
/placeholders/ for objects[fn:1]. When you [[http://www.lispworks.com/documentation/lw50/CLHS/Body/m_setf_.htm][=setf=]] a variable, an object
is "placed" in it. You can place another value to the same variable later, as
you wish.

This implies a fact that in Common Lisp *objects have types*, while
variables do not. This might be surprising at first if you come from a C/C++
background.

For example:

#+BEGIN_SRC lisp
  (defvar *var* 1234)
  *VAR*

  (type-of *var*)
  (INTEGER 0 4611686018427387903)
#+END_SRC

The function [[http://www.lispworks.com/documentation/HyperSpec/Body/f_tp_of.htm][=type-of=]] returns the type of the given object. The
returned result is a [[http://www.lispworks.com/documentation/lw51/CLHS/Body/04_bc.htm][type-specifier]]. In this case the first
element is the type and the remaining part is extra information (lower and
upper bound) of that type. You can safely ignore it for now. Also remember
that integers in Lisp have no limit!

Now let's try to [[http://www.lispworks.com/documentation/lw50/CLHS/Body/m_setf_.htm][=setf=]] the variable:

#+BEGIN_SRC lisp
  * (setf *var* "hello")
  "hello"

  * (type-of *var*)
  (SIMPLE-ARRAY CHARACTER (5))
#+END_SRC

You see, =type-of= returns a different result: [[http://www.lispworks.com/documentation/lw70/CLHS/Body/t_smp_ar.htm][=simple-array=]]
of length 5 with contents of type [[http://www.lispworks.com/documentation/lcl50/ics/ics-14.html][=character=]]. This is because
=*var*= is evaluated to string ="hello"= and the function =type-of= actually
returns the type of object ="hello"= instead of variable =*var*=.

** Type Hierarchy
   :PROPERTIES:
   :CUSTOM_ID: type-hierarchy
   :END:

The inheritance relationship of Lisp types consists a type graph and the root
of all types is =T=. For example:

#+BEGIN_SRC lisp
  * (describe 'integer)
  COMMON-LISP:INTEGER
    [symbol]

  INTEGER names the built-in-class #<BUILT-IN-CLASS COMMON-LISP:INTEGER>:
    Class precedence-list: INTEGER, RATIONAL, REAL, NUMBER, T
    Direct superclasses: RATIONAL
    Direct subclasses: FIXNUM, BIGNUM
    No direct slots.

  INTEGER names a primitive type-specifier:
    Lambda-list: (&OPTIONAL (SB-KERNEL::LOW '*) (SB-KERNEL::HIGH '*))
#+END_SRC

The function [[http://www.lispworks.com/documentation/lw51/CLHS/Body/f_descri.htm][=describe=]] shows that the symbol [[http://www.lispworks.com/documentation/lw71/CLHS/Body/t_intege.htm][=integer=]]
is a primitive type-specifier that has optional information lower bound and
upper bound. Meanwhile, it is a built-in class. But why?

Most common Lisp types are implemented as CLOS classes. Some types are simply
"wrappers" of other types. Each CLOS class maps to a corresponding type. In
Lisp types are referred to indirectly by the use of [[http://www.lispworks.com/documentation/lw51/CLHS/Body/04_bc.htm][=type specifiers=]].

There are some differences between the function [[http://www.lispworks.com/documentation/HyperSpec/Body/f_tp_of.htm][=type-of=]] and
[[http://www.lispworks.com/documentation/HyperSpec/Body/f_clas_1.htm][=class-of=]]. The function =type-of= returns the type of a given
object in type specifier format while =class-of= returns the implementation
details.

#+BEGIN_SRC lisp
  * (type-of 1234)
  (INTEGER 0 4611686018427387903)

  * (class-of 1234)
  #<BUILT-IN-CLASS COMMON-LISP:FIXNUM>
#+END_SRC

** Checking Types
   :PROPERTIES:
   :CUSTOM_ID: checking-types
   :END:

The function [[http://www.lispworks.com/documentation/lw51/CLHS/Body/f_typep.htm][=typep=]] can be used to check if the first argument is of
the given type specified by the second argument.

#+BEGIN_SRC lisp
  * (typep 1234 'integer)
  T
#+END_SRC

The function [[http://www.lispworks.com/documentation/lw71/CLHS/Body/f_subtpp.htm][=subtypep=]] can be used to inspect if a type inherits
from the another one. It returns 2 values: - =T, T= means first argument is sub-type of the second one. - =NIL, T= means first argument is /not/ sub-type of the second one. - =NIL, NIL= means "not determined".

For example:

#+BEGIN_SRC lisp
  * (subtypep 'integer 'number)
  T
  T

  * (subtypep 'string 'number)
  NIL
  T
#+END_SRC

Sometimes you may want to perform different actions according to the type of
an argument. The macro [[http://www.lispworks.com/documentation/lw60/CLHS/Body/m_tpcase.htm][=typecase=]] is your friend:

#+BEGIN_SRC lisp
  * (defun plus1 (arg)
      (typecase arg
        (integer (+ arg 1))
        (string (concatenate 'string arg "1"))
        (t 'error)))
  PLUS1

  * (plus1 100)
  101 (7 bits, #x65, #o145, #b1100101)

  * (plus1 "hello")
  "hello1"

  * (plus1 'hello)
  ERROR
#+END_SRC

** Type Specifier
   :PROPERTIES:
   :CUSTOM_ID: type-specifier
   :END:

A type specifier is a form specifying a type. As mentioned above, returning
value of the function =type-of= and the second argument of =typep= are both
type specifiers.

As shown above, =(type-of 1234)= returns =(INTEGER 0 4611686018427387903)=. This kind of type specifiers are called compound type
specifier. It is a list whose head is a symbol indicating the type. The rest
part of it is complementary information.

#+BEGIN_SRC lisp
  * (typep '#(1 2 3) '(vector number 3))
  T
#+END_SRC

Here the complementary information of the type =vector= is its elements type
and size respectively.

The rest part of a compound type specifier can be a =*=, which means
"anything". For example, the type specifier =(vector number *)= denotes a
vector consisting of any number of numbers.

#+BEGIN_SRC lisp
  * (typep '#(1 2 3) '(vector number *))
  T
#+END_SRC

The trailing parts can be omitted, the omitted elements are treated as
=*=s:

#+BEGIN_SRC lisp
  * (typep '#(1 2 3) '(vector number))
  T

  * (typep '#(1 2 3) '(vector))
  T
#+END_SRC

As you may have guessed, the type specifier above can be shortened as
following:

#+BEGIN_SRC lisp
  * (typep '#(1 2 3) 'vector)
  T
#+END_SRC

You may refer to the [[http://www.lispworks.com/documentation/lw51/CLHS/Body/04_bc.htm][CLHS page]] for more information.

** Defining New Types
   :PROPERTIES:
   :CUSTOM_ID: defining-new-types
   :END:

You can use the macro [[http://www.lispworks.com/documentation/lw51/CLHS/Body/m_deftp.htm][=deftype=]] to define a new type-specifier.

Its argument list can be understood as a direct mapping to elements of rest
part of a compound type specifier. They are defined as optional to allow
symbol type specifier.

Its body should be a macro checking whether given argument is of this type
(see [[http://www.lispworks.com/documentation/lw70/CLHS/Body/m_defmac.htm][=defmacro=]]).

Now let us define a new data type. The data type should be a array with at
most 10 elements. Also each element should be a number smaller than 10. See
following code for an example:

#+BEGIN_SRC lisp
  * (defun small-number-array-p (thing)
      (and (arrayp thing)
        (<= (length thing) 10)
        (every #'numberp thing)
        (every (lambda (x) (< x 10)) thing)))

  * (deftype small-number-array (&optional type)
      `(and (array ,type 1)
            (satisfies small-number-array-p)))

  * (typep '#(1 2 3 4) '(small-number-array number))
  T

  * (typep '#(1 2 3 4) 'small-number-array)
  T

  * (typep '#(1 2 3 4 100) 'small-number-array)
  NIL

  * (small-number-array-p '#(1 2 3 4 5 6 7 8 9 0 1))
  NIL
#+END_SRC

** Type Checking
   :PROPERTIES:
   :CUSTOM_ID: type-checking
   :END:

Common Lisp supports run-time type checking via the macro
[[http://www.lispworks.com/documentation/HyperSpec/Body/m_check_.htm#check-type][=check-type=]]. It accepts a [[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#place][=place=]] and a type specifier
as arguments and signals an [[http://www.lispworks.com/documentation/HyperSpec/Body/e_tp_err.htm#type-error][=type-error=]] if the contents of
place are not of the given type.

#+BEGIN_SRC lisp
  * (defun plus1 (arg)
      (check-type arg number)
      (1+ arg))
  PLUS1

  * (plus1 1)
  2 (2 bits, #x2, #o2, #b10)

  * (plus1 "hello")
  ; Debugger entered on #<SIMPLE-TYPE-ERROR expected-type: NUMBER datum: "Hello">

  The value of ARG is "Hello", which is not of type NUMBER.
     [Condition of type SIMPLE-TYPE-ERROR]
  ...
#+END_SRC

** Compile-time type checking
   :PROPERTIES:
   :CUSTOM_ID: compile-time-type-checking
   :END:

You may provide type information for variables, function arguments
etc via [[http://www.lispworks.com/documentation/HyperSpec/Body/f_procla.htm][=proclaim=]], [[http://www.lispworks.com/documentation/HyperSpec/Body/m_declai.htm][=declaim=]] and [[http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm][=declare=]].
However, similar to the =:type= slot
introduced in [[file:clos.org][CLOS section]], the effects of type declarations are
undefined in Lisp standard and are implementation specific. So there is no
guarantee that the Lisp compiler will perform compile-time type checking.

However, it is possible, and SBCL is an implementation that does
thorough type checking.

Let's recall first that Lisp already warns about simple type
warnings. The following function wrongly wants to concatenate a string
and a number. When we compile it, we get a type warning.

#+BEGIN_SRC lisp
  (defconstant +foo+ 3)
  (defun bar ()
    (concatenate 'string "+" +foo+))
  ; caught WARNING:
  ;   Constant 3 conflicts with its asserted type SEQUENCE.
  ;   See also:
  ;     The SBCL Manual, Node "Handling of Types"
#+END_SRC

The example is simple, but it already shows a capacity some other
languages don't have, and it is actually useful during development ;)
Now, we'll do better.

*** Declaring the type of variables
    :PROPERTIES:
    :CUSTOM_ID: declaring-the-type-of-variables
    :END:

Use the macro [[http://www.lispworks.com/documentation/HyperSpec/Body/m_declai.htm][=declaim=]].

Let's declare that our global variable =*name*= is a string (you can
type the following in any order in the REPL):

#+BEGIN_SRC lisp
  (declaim (type (string) *name*))
  (defparameter *name* "book")
#+END_SRC

Now if we try to set it with a bad type, we get a =simple-type-error=:

#+BEGIN_SRC lisp
  (setf *name* :me)
  Value of :ME in (THE STRING :ME) is :ME, not a STRING.
     [Condition of type SIMPLE-TYPE-ERROR]
#+END_SRC

We can do the same with our custom types. Let's quickly declare the type =list-of-strings=:

#+BEGIN_SRC lisp
  (defun list-of-strings-p (list)
    "Return t if LIST is non nil and contains only strings."
    (and (consp list)
         (every #'stringp list)))

  (deftype list-of-strings ()
    `(satisfies list-of-strings-p))
#+END_SRC

Now let's declare that our =*all-names*= variables is a list of strings:

#+BEGIN_SRC lisp
  (declaim (type (list-of-strings) *all-names*))
  ;; and with a wrong value:
  (defparameter *all-names* "")
  ;; we get an error:
  Cannot set SYMBOL-VALUE of *ALL-NAMES* to "", not of type
  (SATISFIES LIST-OF-STRINGS-P).
     [Condition of type SIMPLE-TYPE-ERROR]
#+END_SRC

We can compose types:

#+BEGIN_SRC lisp
  (declaim (type (or null list-of-strings) *all-names*))
#+END_SRC

*** Declaring the input and output types of functions
    :PROPERTIES:
    :CUSTOM_ID: declaring-the-input-and-output-types-of-functions
    :END:

We use again the =declaim= macro, with =ftype (function …)= instead of just =type=:

#+BEGIN_SRC lisp
  (declaim (ftype (function (fixnum) fixnum) add))
  ;;                         ^^input ^^output [optional]
  (defun add (n)
    (+ n  1))
#+END_SRC

With this we get nice type warnings at compile time.

If we change the function to erroneously return a string instead of a
fixnum, we get a warning:

#+BEGIN_SRC lisp
  (defun add (n)
    (format nil "~a" (+ n  1)))
  ; caught WARNING:
  ;   Derived type of ((GET-OUTPUT-STREAM-STRING STREAM)) is
  ;     (VALUES SIMPLE-STRING &OPTIONAL),
  ;   conflicting with the declared function return type
  ;     (VALUES FIXNUM &REST T).
#+END_SRC

If we use =add= inside another function, to a place that expects a
string, we get a warning:

#+BEGIN_SRC lisp
  (defun bad-concat (n)
    (concatenate 'string (add n)))
  ; caught WARNING:
  ;   Derived type of (ADD N) is
  ;     (VALUES FIXNUM &REST T),
  ;   conflicting with its asserted type
  ;     SEQUENCE.
#+END_SRC

If we use =add= inside another function, and that function declares
its argument types which appear to be incompatible with those of
=add=, we get a warning:

#+BEGIN_SRC lisp
  (declaim (ftype (function (string)) bad-arg))
  (defun bad-arg (n)
      (add n))
  ; caught WARNING:
  ;   Derived type of N is
  ;     (VALUES STRING &OPTIONAL),
  ;   conflicting with its asserted type
  ;     FIXNUM.
#+END_SRC

This all happens indeed /at compile time/, either in the REPL,
either with a simple =C-c C-c= in Slime, or when we =load= a file.

*** Declaring &key parameters
    :PROPERTIES:
    :CUSTOM_ID: declaring-key-parameters
    :END:

Use =&key (:argument type)=.

For example:

#+BEGIN_EXAMPLE
  (declaim (ftype (function (string &key (:n integer))) foo))
  (defun foo (bar &key n) …)
#+END_EXAMPLE

*** Declaring class slots types
    :PROPERTIES:
    :CUSTOM_ID: declaring-class-slots-types
    :END:

A class slot accepts a =:type= slot option. It is however generally
/not/ used to check the type of the initform. SBCL, starting with
[[http://www.sbcl.org/news.html#1.5.9][version 1.5.9]] released on
november 2019, now gives those warnings, meaning that this:

#+BEGIN_SRC lisp
  (defclass foo ()
    ((name :type number :initform "17")))
#+END_SRC

throws a warning at compile time.

Note: see also [[https://github.com/fisxoj/sanity-clause][sanity-clause]], a data
serialization/contract library to check slots' types during
=make-instance= (which is not compile time).

*** Alternative type checking syntax: defstar, serapeum
    :PROPERTIES:
    :CUSTOM_ID: alternative-type-checking-syntax-defstar-serapeum
    :END:

The [[https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#types][Serapeum]] library provides a shortcut that looks like this:

#+BEGIN_SRC lisp
   (-> mod-fixnum+ (fixnum fixnum) fixnum)
   (defun mod-fixnum+ (x y) ...)
#+END_SRC

The [[https://github.com/lisp-mirror/defstar][Defstar]] library provides
a =defun*= macro that allows to add the type declarations into the
lambda list. It looks like this:

#+BEGIN_SRC lisp
  (defun* sum ((a real) (b real))
     (+ a b))
#+END_SRC

It also allows:

- to declare the return type, either in the function definition or in its body
- to quickly declare variables that are ignored, with the =_= placeholder
- to add assertions for each arguments
- to do the same with =defmethod=, =defparameter=, =defvar=, =flet=, =labels=, =let*= and =lambda=.

*** Limitations
    :PROPERTIES:
    :CUSTOM_ID: limitations
    :END:

Complex types involving =satisfies= are not checked inside a function
body, only at its boundaries. Even if it does a lot, SBCL doesn't do
as much as a statically typed language.

Consider this example, where we badly increment an integer with a
string:

#+BEGIN_SRC lisp
  (declaim (ftype (function () string) bad-adder))
  (defun bad-adder ()
    (let ((res 10))
      (loop for name in '("alice")
         do (incf res name))  ;; bad
      (format nil "finally doing sth with ~a" res)))
#+END_SRC

Compiling this function doesn't throw a type warning.

However, if we had the problematic line at the function's boundary
we'd get the warning:

#+BEGIN_SRC lisp
  (defun bad-adder ()
    (let ((res 10))
      (loop for name in  '("alice")
         return (incf res name))))
  ; in: DEFUN BAD-ADDER
  ;     (SB-INT:NAMED-LAMBDA BAD-ADDER
  ;         NIL
  ;       (BLOCK BAD-ADDER
  ;         (LET ((RES 10))
  ;           (LOOP FOR NAME IN *ALL-NAMES* RETURN (INCF RES NAME)))))
  ;
  ; caught WARNING:
  ;   Derived type of ("a hairy form" NIL (SETQ RES (+ NAME RES))) is
  ;     (VALUES (OR NULL NUMBER) &OPTIONAL),
  ;   conflicting with the declared function return type
  ;     (VALUES STRING &REST T).
#+END_SRC

What can we conclude? This is yet another reason to decompose your
code into small functions.

** See also
   :PROPERTIES:
   :CUSTOM_ID: see-also
   :END:

- the article [[https://medium.com/@MartinCracauer/static-type-checking-in-the-programmable-programming-language-lisp-79bb79eb068a][Static type checking in SBCL]], by Martin Cracauer
- the article [[https://alhassy.github.io/TypedLisp][Typed List, a Primer]] - let's explore Lisp's fine-grained type hierarchy! with a shallow comparison to Haskell.
- the [[https://github.com/coalton-lang/coalton/][Coalton]] library: an
  efficient, statically typed functional programming language that
  supercharges Common Lisp. It is as an embedded DSL in Lisp that
  resembles Haskell or Standard ML, but lets you seamlessly
  interoperate with non-statically-typed Lisp code (and vice versa).

--------------

[fn:1] The term /object/ here has nothing to do with Object-Oriented or so. It
       means "any Lisp datum".
