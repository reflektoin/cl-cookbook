#+BEGIN_HTML
  <!-- needs some text before the first heading -->
#+END_HTML

** Introduction: loop, iterate, for, mapcar, series
   :PROPERTIES:
   :CUSTOM_ID: introduction-loop-iterate-for-mapcar-series
   :END:

*[[http://www.lispworks.com/documentation/lw51/CLHS/Body/m_loop.htm][loop]]*
is the built-in macro for iteration.

Its simplest form is =(loop (print "hello"))=: this will print forever.

A simple iteration over a list is:

#+BEGIN_SRC lisp
  (loop for x in '(1 2 3)
    do (print x))
#+END_SRC

It prints what's needed but returns =nil=.

If you want to return a list, use =collect=:

#+BEGIN_SRC lisp
  (loop for x in '(1 2 3)
    collect (* x 10))
  ;; (10 20 30)
#+END_SRC

The Loop macro is different than most Lisp expressions in having a complex
internal domain-specific language that doesn't use s-expressions.
So you need to read Loop expressions with half of your brain in Lisp mode, and
the other half in Loop mode. You love it or you hate it.

Think of Loop expressions as having four parts: expressions that set up
variables that will be iterated, expressions that conditionally terminate the
iteration, expressions that do something on each iteration, and expressions that
do something right before the Loop exits. In addition, Loop expressions can
return a value. It is very rare to use all of these parts in a given Loop
expression, but you can combine them in many ways.

*[[https://common-lisp.net/project/iterate/doc/index.org][iterate]]* is a
popular iteration macro that aims at being simpler, "lispier" and more
predictable than =loop=, besides being extensible. However it isn't built-in,
so you have to import it:

#+BEGIN_EXAMPLE
  (ql:quickload "iterate")
  (use-package :iterate)
#+END_EXAMPLE

Iterate looks like this:

#+BEGIN_SRC lisp
  (iter (for i from 1 to 5)
      (collect (* i i)))
#+END_SRC

(if you use loop and iterate in the same package, you might run into name conflicts)

Iterate also comes with =display-iterate-clauses= that can be quite handy:

#+BEGIN_SRC lisp
  (display-iterate-clauses '(for))
  ;; FOR PREVIOUS &OPTIONAL INITIALLY BACK     Previous value of a variable
  ;; FOR FIRST THEN            Set var on first, and then on subsequent iterations
  ;; ...
#+END_SRC

Much of the examples on this page that are valid for loop are also valid for iterate,
with minor modifications.

*[[https://github.com/Shinmera/for/][for]]* is an extensible iteration
macro that is often shorter than loop, that "unlike loop is extensible
and sensible, and unlike iterate does not require code-walking and is
easier to extend".

It has the other advantage of having one construct that works for all
data structures (lists, vectors, hash-tables...): in doubt, just use
=for… over=:

#+BEGIN_SRC lisp
  (for:for ((x over <your data structure>))
     (print …))
#+END_SRC

You also have to quickload it:

#+BEGIN_EXAMPLE
  (ql:quickload "for")
#+END_EXAMPLE

We'll also give examples with *=mapcar=* and =map=, and eventually
with their friends =mapcon=, =mapcan=, =maplist=, =mapc= and =mapl=
which E. Weitz categorizes very well in his "Common Lisp Recipes",
chap. 7. The one you are certainly accustomed to from other languages is
=mapcar=: it takes a function, one or more lists as arguments,
applies the function on each /element/ of the lists one by one and
returns a list of result.

#+BEGIN_SRC lisp
  (mapcar (lambda (it) (+ it 10)) '(1 2 3))
  (11 12 13)
#+END_SRC

=map= is generic, it accepts list and vectors as arguments, and
expects the type for its result as first argument:

#+BEGIN_SRC lisp
  (map 'vector (lambda (it) (+ it 10)) '(1 2 3))
  ;; #(11 12 13)
  (map 'list (lambda (it) (+ it 10)) #(1 2 3))
  ;; (11 12 13)
  (map 'string (lambda (it) (code-char it)) '#(97 98 99))
  ;; "abc"
#+END_SRC

The other constructs have their advantages in some situations ;) They
either process the /tails/ of lists, or /concatenate/ the return
values, or don't return anything. We'll see some of them.

If you like =mapcar=, use it a lot, and would like a quicker and
shorter way to write lambdas, then you might like one of those
[[https://github.com/CodyReichert/awesome-cl#lambda-shorthands][lambda shorthand libraries]].

Here is an example with [[https://github.com/windymelt/cl-punch/][cl-punch]]:

#+BEGIN_SRC lisp
  (mapcar ^(* _ 10) '(1 2 3))
  ;; (10 20 30)
#+END_SRC

and voilà :) We won't use this more in this recipe, but feel free to do.

Last but not least, you might like
*[[http://series.sourceforge.net/][series]]*,
a library that describes itself as combining aspects of sequences,
streams, and loops. Series expressions look like operations on
sequences (= functional programming), but can achieve the same high level of efficiency as a
loop. Series first appeared in "Common Lisp the Language", in the
appendix A (it nearly became part of the language). Series looks like
this:

#+BEGIN_SRC lisp
  (collect
    (mapping ((x (scan-range :from 1 :upto 5)))
      (* x x)))
  ;; (1 4 9 16 25)
#+END_SRC

=series= is good, but its function names are different from what we
find in functional languages today. You might like the [[https://github.com/cbeo/gtwiwtg]["Generators
The Way I Want Them Generated"]]
library. It is a lazy sequences library, similar to =series= although
younger and not as complete, with a "modern" API with words like =take=, =filter=,
=for= or =fold=, and that is easy to use.

#+BEGIN_SRC lisp
  (range :from 20)
  ;; #<GTWIWTG::GENERATOR! {1001A90CA3}>

  (take 4 (range :from 20))
  ;; (20 21 22 23)
#+END_SRC

At the time of writing, GTWIWTG is licensed under the GPLv3.

** Recipes
   :PROPERTIES:
   :CUSTOM_ID: recipes
   :END:

*** Looping forever, return
    :PROPERTIES:
    :CUSTOM_ID: looping-forever-return
    :END:

#+BEGIN_SRC lisp
  (loop
      (print "hello"))
#+END_SRC

=return= can return a result:

#+BEGIN_SRC lisp
  (loop for i in '(1 2 3)
       when (> i 1)
       return i)
  2
#+END_SRC

*** Looping a fixed number of times
    :PROPERTIES:
    :CUSTOM_ID: looping-a-fixed-number-of-times
    :END:

**** dotimes
     :PROPERTIES:
     :CUSTOM_ID: dotimes
     :END:

#+BEGIN_SRC lisp
  (dotimes (n 10)
    (print n))
#+END_SRC

Here =dotimes= returns =nil=. The return value is evaluated at the end of the loop.

You can use =return= inside of it:

#+BEGIN_SRC lisp
  (dotimes (i 10)
     (if (> i 3)
         (return)
         (print i)))
#+END_SRC

**** loop... repeat
     :PROPERTIES:
     :CUSTOM_ID: loop-repeat
     :END:

#+BEGIN_SRC lisp
  (loop repeat 10
    do (format t "Hello!~%"))
#+END_SRC

This prints 10 times "hello" and returns =nil=.

#+BEGIN_SRC lisp
  (loop repeat 10 collect (random 10))
  ;; (5 1 3 5 4 0 7 4 9 1)
#+END_SRC

with =collect=, this returns a list.

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series
     :END:

#+BEGIN_SRC lisp
  (iterate ((n (scan-range :below 10)))
    (print n))
#+END_SRC

*** Looping an infinite number of times, cycling over a circular list
    :PROPERTIES:
    :CUSTOM_ID: looping-an-infinite-number-of-times-cycling-over-a-circular-list
    :END:

We can build an infinite list by setting its last element to the list itself:

#+BEGIN_SRC lisp
  (loop with list-a = '(1 2 3)
        with infinite-list = (setf (cdr (last list-a)) list-a)
        for item in infinite-list
        repeat 8
        collect item)
  ;; (1 2 3 1 2 3 1 2)
#+END_SRC

Illustration: =(last '(1 2 3))= is =(3)=, a list, or rather a cons cell, whose =car= is 3 and =cdr= is NIL. See the [[file:data-structures.org][data-structures chapter]] for a reminder. This is the representation of =(list 3)=:

#+BEGIN_EXAMPLE
  [o|/]
   |
   3
#+END_EXAMPLE

The representation of =(list 1 2 3)=:

#+BEGIN_EXAMPLE
  [o|o]---[o|o]---[o|/]
   |       |       |
   1       2       3
#+END_EXAMPLE

By setting the =cdr= of the last element to the list itself, we make it recur on itself.

A notation shortcut is possible with the =#== syntax:

#+BEGIN_SRC lisp
  (defparameter *list-a* '#1=(1 2 3 . #1#))
  (setf *print-circle* t)  ;; don't print circular lists forever
  *list-a*
#+END_SRC

If you need to alternate only between two values, use =for … then=:

#+BEGIN_SRC lisp
  (loop repeat 4
        for up = t then (not up)
        do (print up))
  T
  NIL
  T
  NIL
#+END_SRC

*** Iterate's for loop
    :PROPERTIES:
    :CUSTOM_ID: iterates-for-loop
    :END:

For lists and vectors:

#+BEGIN_SRC lisp
  (iter (for item in '(1 2 3))
    (print item))
  (iter (for i in-vector #(1 2 3))
    (print i))
#+END_SRC

Looping over a hash-table is also straightforward:

#+BEGIN_SRC lisp
  (let ((h (let ((h (make-hash-table)))
             (setf (gethash 'a h) 1)
             (setf (gethash 'b h) 2)
             h)))
    (iter (for (k v) in-hashtable h)
      (print k)))
  ;; b
  ;; a
#+END_SRC

In fact, take a look [[https://common-lisp.net/project/iterate/doc/Sequence-Iteration.html][here]],
or =(display-iterate-clauses '(for))= to know about iterating over

- symbols in-package
- forms - or lines, or whatever-you-wish - in-file, or in-stream
- elements in-sequence - sequences can be vectors or lists

*** Looping over a list
    :PROPERTIES:
    :CUSTOM_ID: looping-over-a-list
    :END:

**** dolist
     :PROPERTIES:
     :CUSTOM_ID: dolist
     :END:

#+BEGIN_SRC lisp
  (dolist (item '(1 2 3))
    (print item))
#+END_SRC

=dolist= returns =nil=.

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop
     :END:

with =in=, no surprises:

#+BEGIN_SRC lisp
  (loop for x in '(a b c)
        do (print x))
  ;; A
  ;; B
  ;; C
  ;; NIL
#+END_SRC

#+BEGIN_SRC lisp
  (loop for x in '(a b c)
        collect x)
  ;; (A B C)
#+END_SRC

With =on=, we loop over the cdr of the list:

#+BEGIN_SRC lisp
  (loop for i on '(1 2 3) do (print i))
  ;; (1 2 3)
  ;; (2 3)
  ;; (3)
#+END_SRC

**** mapcar
     :PROPERTIES:
     :CUSTOM_ID: mapcar
     :END:

#+BEGIN_SRC lisp
  (mapcar (lambda (x)
               (print (* x 10)))
           '(1 2 3))
  10
  20
  30
  (10 20 30)
#+END_SRC

=mapcar= returns the results of the lambda function as a list.

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-1
     :END:

#+BEGIN_SRC lisp
  (iterate ((item (scan '(1 2 3))))
    (print item))
#+END_SRC

=scan-sublists= is the equivalent of =loop for ... on=:

#+BEGIN_SRC lisp
  (iterate ((i (scan-sublists '(1 2 3))))
    (print i))
#+END_SRC

*** Looping over a vector
    :PROPERTIES:
    :CUSTOM_ID: looping-over-a-vector
    :END:

**** loop: =across=
     :PROPERTIES:
     :CUSTOM_ID: loop-across
     :END:

#+BEGIN_SRC lisp
  (loop for i across #(1 2 3) do (print i))
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-2
     :END:

#+BEGIN_SRC lisp
  (iterate ((i (scan #(1 2 3))))
    (print i))
#+END_SRC

*** Looping over a hash-table
    :PROPERTIES:
    :CUSTOM_ID: looping-over-a-hash-table
    :END:

We create a hash-table:

#+BEGIN_SRC lisp
  (defparameter h (make-hash-table))
  (setf (gethash 'a h) 1)
  (setf (gethash 'b h) 2)
#+END_SRC

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-1
     :END:

Looping over keys:

#+BEGIN_SRC lisp
  (loop for k being the hash-key of h do (print k))
  ;; b
  ;; a
#+END_SRC

same with =hash-value=.

Looping over key-values pairs:

#+BEGIN_SRC lisp
  (loop for k
      being the hash-key
      using (hash-value v) of h
      do (format t "~a ~a~%" k v))
  b 2
  a 1
#+END_SRC

**** iterate
     :PROPERTIES:
     :CUSTOM_ID: iterate
     :END:

Use =in-hashtable=:

#+BEGIN_SRC lisp
  (iter (for (key value) in-hashtable h)
    (collect (list key value)))
#+END_SRC

**** for
     :PROPERTIES:
     :CUSTOM_ID: for
     :END:

the same with =for=:

#+BEGIN_SRC lisp
  (for:for ((it over h))
      (print it))
  (A 1)
  (B 2)
  NIL
#+END_SRC

**** maphash
     :PROPERTIES:
     :CUSTOM_ID: maphash
     :END:

The lambda function of =maphash= takes two arguments: the key and the
value:

#+BEGIN_SRC lisp
  (maphash (lambda (key val)
               (format t "key: ~a val:~a~&" key val))
            h)
  ;; key: A val:1
  ;; key: B val:2
  ;; NIL
#+END_SRC

See also [[http://www.lispworks.com/documentation/HyperSpec/Body/m_w_hash.htm][with-hash-table-iterator]].

**** dohash
     :PROPERTIES:
     :CUSTOM_ID: dohash
     :END:

Only because we like this topic, we introduce another library, [[https://github.com/yitzchak/trivial-do/][trivial-do]]. It has the =dohash= macro, that ressembles =dolist=:

#+BEGIN_SRC lisp
  (dohash (key value h)
    (format t "key: ~A, value: ~A~%" key value))
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-3
     :END:

#+BEGIN_SRC lisp
  (iterate (((k v) (scan-hash h)))
    (format t "~&~a ~a~%" k v))
#+END_SRC

*** Looping over two lists in parallel
    :PROPERTIES:
    :CUSTOM_ID: looping-over-two-lists-in-parallel
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-2
     :END:

#+BEGIN_SRC lisp
  (loop for x in '(a b c)
        for y in '(1 2 3)
        collect (list x y))
  ;; ((A 1) (B 2) (C 3))
#+END_SRC

To return a flat list, use =nconcing= instead of =collect=:

#+BEGIN_SRC lisp
  (loop for x in '(a b c)
        for y in '(1 2 3)
        nconcing (list x y))
  (A 1 B 2 C 3)
#+END_SRC

If a list is smaller than the other one, loop stops at the end of the small one:

#+BEGIN_SRC lisp
  (loop for x in '(a b c)
        for y in '(1 2 3 4 5)
        collect (list x y))
  ;; ((A 1) (B 2) (C 3))
#+END_SRC

We could loop over the biggest list and manually access the elements
of the smaller one by index, but it would quickly be
inefficient. Instead, we can tell =loop= to extend the short list.

#+BEGIN_SRC lisp
  (loop for y in '(1 2 3 4 5)
        for x-list = '(a b c) then (cdr x-list)
        for x = (or (car x-list) 'z)
        collect (list x y))
  ;; ((A 1) (B 2) (C 3) (Z 4) (Z 5))
#+END_SRC

The trick is that the notation =for … = … then (cdr …)= (note the ===
and the role of =then=) shortens our intermediate list at each
iteration (thanks to =cdr=). It will first be ='(a b c)=, the initial
value, then we will get the =cdr=: =(2 3)=, then =(3)=, then
=NIL=. And both =(car NIL)= and =(cdr NIL)= return =NIL=, so we are
good.

**** mapcar
     :PROPERTIES:
     :CUSTOM_ID: mapcar-1
     :END:

#+BEGIN_SRC lisp
  (mapcar (lambda (x y)
            (list x y))
          '(a b c)
          '(1 2 3))
  ;; ((A 1) (B 2) (C 3))
#+END_SRC

or simply:

#+BEGIN_SRC lisp
  (mapcar #'list
          '(a b c)
          '(1 2 3))
  ;; ((A 1) (B 2) (C 3))
#+END_SRC

Return a flat list:

#+BEGIN_SRC lisp
  (mapcan (lambda (x y)
            (list x y))
          '(a b c)
          '(1 2 3))
  ;; (A 1 B 2 C 3)
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-4
     :END:

#+BEGIN_SRC lisp
  (collect
    (#Mlist (scan '(a b c))
            (scan '(1 2 3))))
#+END_SRC

A more efficient way, when the lists are known to be of equal length:

#+BEGIN_SRC lisp
  (collect
    (mapping (((x y) (scan-multiple 'list
                                    '(a b c)
                                    '(1 2 3))))
      (list x y)))
#+END_SRC

Return a flat list:

#+BEGIN_SRC lisp
  (collect-append ; or collect-nconc
   (mapping (((x y) (scan-multiple 'list
                                   '(a b c)
                                   '(1 2 3))))
     (list x y)))
#+END_SRC

*** Nested loops
    :PROPERTIES:
    :CUSTOM_ID: nested-loops
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-3
     :END:

#+BEGIN_SRC lisp
  (loop for x from 1 to 3
        collect (loop for y from 1 to x
              collect y))
  ;; ((1) (1 2) (1 2 3))
#+END_SRC

To return a flat list, use =nconcing= instead of the first =collect=.

**** iterate
     :PROPERTIES:
     :CUSTOM_ID: iterate-1
     :END:

#+BEGIN_SRC lisp
  (iter outer
     (for i below 2)
     (iter (for j below 3)
        (in outer (collect (list i j)))))
  ;; ((0 0) (0 1) (0 2) (1 0) (1 1) (1 2))
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-5
     :END:

#+BEGIN_SRC lisp
  (collect
    (mapping ((x (scan-range :from 1 :upto 3)))
      (collect (scan-range :from 1 :upto x))))
#+END_SRC

*** Computing an intermediate value
    :PROPERTIES:
    :CUSTOM_ID: computing-an-intermediate-value
    :END:

Use ===.

With =for=:

#+BEGIN_SRC lisp
  (loop for x from 1 to 3
        for y = (* x 10)
        collect y)
  ;; (10 20 30)
#+END_SRC

With =with=, the difference being that the value is computed only
once:

#+BEGIN_SRC lisp
  (loop for x from 1 to 3
        for y = (* x 10)
        with z = x
        collect (list x y z))
  ;; ((1 10 1) (2 20 1) (3 30 1))
#+END_SRC

The HyperSpec defines the =with= clause like this:

#+BEGIN_EXAMPLE
  with-clause::= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}*
#+END_EXAMPLE

so it turns out we can specify the type before the === and chain the =with= with =and=:

#+BEGIN_SRC lisp
  (loop for x from 1 to 3
        for y integer = (* x 10)
        with z integer = x
        collect (list x y z))
#+END_SRC

#+BEGIN_SRC lisp
  (loop for x upto 3
        with foo = :foo
        and bar = :bar
        collect (list x foo bar))
#+END_SRC

We can also give =for= a =then= clause that will be called at each iteration:

#+BEGIN_SRC lisp
  (loop repeat 3
        for intermediate = 10 then (incf intermediate)
        do (print intermediate))
  10
  11
  12
#+END_SRC

Here's a trick to alternate a boolean:

#+BEGIN_SRC lisp
  (loop repeat 4
        for up = t then (not up)
        do (print up))

  T
  NIL
  T
  NIL
#+END_SRC

*** Loop with a counter
    :PROPERTIES:
    :CUSTOM_ID: loop-with-a-counter
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-4
     :END:

Iterate through a list, and have a counter iterate in parallel. The length of
the list determines when the iteration ends. Two sets of actions are defined,
one of which is executed conditionally.

#+BEGIN_SRC lisp
  * (loop for x in '(a b c d e)
        for y from 1

        when (> y 1)
        do (format t ", ")

        do (format t "~A" x)
        )

  A, B, C, D, E
  NIL
#+END_SRC

We could also write the preceding loop using the IF construct.

#+BEGIN_SRC lisp
  * (loop for x in '(a b c d e)
        for y from 1

        if (> y 1)
        do (format t ", ~A" x)
        else do (format t "~A" x)
        )

  A, B, C, D, E
  NIL
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-6
     :END:

By iterating on multiple series in parallel, and using an infinite
range, we can make a counter.

#+BEGIN_SRC lisp
  (iterate ((x (scan '(a b c d e)))
            (y (scan-range :from 1)))
    (when (> y 1) (format t ", "))
    (format t "~A" x))
#+END_SRC

*** Ascending, descending order, limits
    :PROPERTIES:
    :CUSTOM_ID: ascending-descending-order-limits
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-5
     :END:

=from… to…=:

#+BEGIN_SRC lisp
  (loop for i from 0 to 10
        do (print i))
  ;; 0 1 2 3 4 5 6 7 8 9 10
#+END_SRC

=from… below…=: this stops at 9:

#+BEGIN_SRC lisp
  (loop for i from 0 below 10
        do (print i))
#+END_SRC

Similarly, use =from 10 downto 0= (10...0) and =from 10 above 0= (10...1).

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-7
     :END:

=:from ... :upto=, including the upper limit:

#+BEGIN_SRC lisp
  (iterate ((i (scan-range :from 0 :upto 10)))
    (print i))
#+END_SRC

=:from ... :below=, excluding the upper limit:

#+BEGIN_SRC lisp
  (iterate ((i (scan-range :from 0 :below 10)))
    (print i))
#+END_SRC

*** Steps
    :PROPERTIES:
    :CUSTOM_ID: steps
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-6
     :END:

with =by=:

#+BEGIN_SRC lisp
  (loop for i from 1 to 10 by 2
        do (print i))
#+END_SRC

if you use =by (1+ (random 3))=, the random is evaluated only once, as
if it was in a closure:

#+BEGIN_SRC lisp
  (let ((step (random 3)))
     (loop for i from 1 to 10 by (+ 1 step)
        do (print i)))
#+END_SRC

The step must always be a positive number. If you want to count down, see above.

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-8
     :END:

with =:by=
~+lisp
(iterate ((i (scan-range :from 1 :upto 10 :by 2)))
(print i))+~

*** Loop and conditionals
    :PROPERTIES:
    :CUSTOM_ID: loop-and-conditionals
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-7
     :END:

with =if=, =else= and =finally=:

#+BEGIN_SRC lisp
  ;; https://riptutorial.com/common-lisp/example/11095/conditionally-executing-loop-clauses
  (loop repeat 10
        for x = (random 100)
        if (evenp x)
          collect x into evens
        else
          collect x into odds
        finally (return (values evens odds)))
#+END_SRC

#+BEGIN_EXAMPLE
  (42 82 24 92 92)
  (55 89 59 13 49)
#+END_EXAMPLE

Combining multiple clauses in an if body requires special syntax (=and do=, =and count=):

#+BEGIN_SRC lisp
   (loop repeat 10
         for x = (random 100)
         if (evenp x)
            collect x into evens
            and do (format t "~a is even!~%" x)
         else
            collect x into odds
            and count t into n-odds
         finally (return (values evens odds n-odds)))
#+END_SRC

#+BEGIN_EXAMPLE
  46 is even!
  8 is even!
  76 is even!
  58 is even!
  0 is even!
  (46 8 76 58 0)
  (7 45 43 15 69)
  5
#+END_EXAMPLE

**** iterate
     :PROPERTIES:
     :CUSTOM_ID: iterate-2
     :END:

Translating (or even writing!) the above example using iterate is straight-forward:

#+BEGIN_SRC lisp
  (iter (repeat 10)
     (for x = (random 100))
     (if (evenp x)
         (progn
           (collect x into evens)
           (format t "~a is even!~%" x))
         (progn
           (collect x into odds)
           (count t into n-odds)))
     (finally (return (values evens odds n-odds))))
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-9
     :END:

The preceding loop would be done a bit differently in Series. =split=
sorts one series into multiple according to provided boolean series.

#+BEGIN_SRC lisp
  (let* ((number (#M(lambda (n) (random 100))
                    (scan-range :below 10)))
         (parity (#Mevenp number)))
    (iterate ((n number) (p parity))
      (when p (format t "~a is even!~%" n)))
    (multiple-value-bind (evens odds) (split number parity)
      (values (collect evens)
              (collect odds)
              (collect-length odds))))
#+END_SRC

Note that although =iterate= and the three =collect= expressions are
written sequentially, only one iteration is performed, the same as the
example with loop.

*** Begin the loop with a clause (initially)
    :PROPERTIES:
    :CUSTOM_ID: begin-the-loop-with-a-clause-initially
    :END:

#+BEGIN_SRC lisp
  (loop initially
        (format t "~a " 'loop-begin)
        for x below 3
        do (format t "~a " x))
  ;; LOOP-BEGIN 0 1 2
#+END_SRC

=initially= also exists with =iterate=.

*** Terminate the loop with a test (until, while)
    :PROPERTIES:
    :CUSTOM_ID: terminate-the-loop-with-a-test-until-while
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-8
     :END:

#+BEGIN_SRC lisp
  (loop for x in '(1 2 3 4 5)
      until (> x 3)
      collect x)
  ;; (1 2 3)
#+END_SRC

the same, with =while=:

#+BEGIN_SRC lisp
  (loop for x in '(1 2 3 4 5)
      while (< x 4)
      collect x)
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-10
     :END:

We truncate the series with =until-if=, then collect from its result.

#+BEGIN_SRC lisp
  (collect
    (until-if (lambda (i) (> i 3))
              (scan '(1 2 3 4 5))))
#+END_SRC

*** Loop, print and return a result
    :PROPERTIES:
    :CUSTOM_ID: loop-print-and-return-a-result
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-9
     :END:

=do= and =collect= can be combined in one expression

#+BEGIN_SRC lisp
  (loop for x in '(1 2 3 4 5)
      while (< x 4)
          do (format t "x is ~a~&" x)
      collect x)
  x is 1
  x is 2
  x is 3
  (1 2 3)
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-11
     :END:

By mapping, we can perform a side effect and also collect items

#+BEGIN_SRC lisp
  (collect
    (mapping ((x (until-if (complement (lambda (x) (< x 4)))
                           (scan '(1 2 3 4 5)))))
      (format t "x is ~a~&" x)
      x))
#+END_SRC

*** Named loops and early exit
    :PROPERTIES:
    :CUSTOM_ID: named-loops-and-early-exit
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-10
     :END:

The special =loop named= foo syntax allows you to create a loop that
you can exit early from. The exit is performed using =return-from=,
and can be used from within nested loops.

#+BEGIN_SRC lisp
  ;; useless example
  (loop named loop-1
      for x from 0 to 10 by 2
      do (loop for y from 0 to 100 by (1+ (random 3))
              when (< x y)
              do (return-from loop-1 (values x y))))
  0
  2
#+END_SRC

Sometimes, you want to return early but execute the =finally= clause
anyways. Use [[http://www.lispworks.com/documentation/HyperSpec/Body/m_loop_f.htm#loop-finish][=loop-finish=]].

#+BEGIN_SRC lisp
  (loop for x from 0 to 100
    do (print x)
    when (>= x 3)
    return x
    finally (print :done))  ;; <-- not printed
  ;; 0
  ;; 1
  ;; 2
  ;; 3
  ;; 3

  (loop for x from 0 to 100
    do (print x)
    when (>= x 3)
    do (loop-finish)
    finally (print :done)
       (return x))
  ;; 0
  ;; 1
  ;; 2
  ;; 3
  ;; :DONE
  ;; 3
#+END_SRC

It is most needed when some computation must take place in the =finally= clause.

**** Loop shorthands for when/return
     :PROPERTIES:
     :CUSTOM_ID: loop-shorthands-for-whenreturn
     :END:

Several actions provide shorthands for combinations of when/return:

#+BEGIN_SRC lisp
  * (loop for x in '(foo 2)
        thereis (numberp x))
  T
#+END_SRC

#+BEGIN_SRC lisp
  * (loop for x in '(foo 2)
        never (numberp x))
  NIL
#+END_SRC

#+BEGIN_SRC lisp
  * (loop for x in '(foo 2)
        always (numberp x))
  NIL
#+END_SRC

They correspond to the functions =some=, =notany= and =every=:

#+BEGIN_SRC lisp
  (some #'numberp '(foo 2))
  (notany #'numberp '(foo 2))
  (every #'numberp '(foo 2))
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-12
     :END:

A block is manually created and returned from.

#+BEGIN_SRC lisp
  (block loop-1
    (iterate ((x (scan-range :from 0 :upto 10 :by 2)))
      (iterate ((y (scan-range :from 0 :upto 100 :by (1+ (random 3)))))
        (when (< x y)
          (return-from loop-1 (values x y))))))
#+END_SRC

*** Count
    :PROPERTIES:
    :CUSTOM_ID: count
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-11
     :END:

#+BEGIN_SRC lisp
  (loop for i from 1 to 3 count (oddp i))
  ;; 2
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-13
     :END:

#+BEGIN_SRC lisp
  (collect-length (choose-if #'oddp (scan-range :from 1 :upto 3)))
#+END_SRC

*** Summation
    :PROPERTIES:
    :CUSTOM_ID: summation
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-12
     :END:

#+BEGIN_SRC lisp
  (loop for i from 1 to 3 sum (* i i))
  ;; 14
#+END_SRC

Summing into a variable:

#+BEGIN_SRC lisp
  (loop for i from 1 to 3
     sum (* i i) into total
     do (print i)
     finally (print total))
  1
  2
  3
  14
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-14
     :END:

#+BEGIN_SRC lisp
  (collect-sum (#M(lambda (i) (* i i))
                  (scan-range :from 1 :upto 3)))
#+END_SRC

*** max, min
    :PROPERTIES:
    :CUSTOM_ID: max-min
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-13
     :END:

#+BEGIN_SRC lisp
  (loop for i from 1 to 3 maximize (mod i 3))
  ;; 2
#+END_SRC

and =minimize=.

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-15
     :END:

#+BEGIN_SRC lisp
  (collect-max (#M(lambda (i) (mod i 3))
                  (scan-range :from 1 :upto 3)))
#+END_SRC

and =collect-min=.

*** Destructuring, aka pattern matching against the list or dotted pairs
    :PROPERTIES:
    :CUSTOM_ID: destructuring-aka-pattern-matching-against-the-list-or-dotted-pairs
    :END:

**** loop
     :PROPERTIES:
     :CUSTOM_ID: loop-14
     :END:

#+BEGIN_SRC lisp
  (loop for (a b) in '((x 1) (y 2) (z 3))
        collect (list b a) )
  ;; ((1 X) (2 Y) (3 Z))
#+END_SRC

#+BEGIN_SRC lisp
  (loop for (x . y) in '((1 . a) (2 . b) (3 . c)) collect y)
  ;; (A B C)
#+END_SRC

Use =nil= to ignore a term:

#+BEGIN_SRC lisp
  (loop for (a nil) in '((x 1) (y 2) (z 3))
        collect a )
  ;; (X Y Z)
#+END_SRC

***** Iterating 2 by 2 over a list
      :PROPERTIES:
      :CUSTOM_ID: iterating-2-by-2-over-a-list
      :END:

To iterate over a list, 2 items at a time we use a combination of =on=, =by= and destructuring.

We use =on= to loop over the rest (the =cdr=) of the list.

#+BEGIN_SRC lisp
  (loop for rest on '(a 2 b 2 c 3)
        collect rest)
  ;; ((A 2 B 2 C 3) (2 B 2 C 3) (B 2 C 3) (2 C 3) (C 3) (3))
#+END_SRC

We use =by= to skip one element at every iteration (=(cddr list)= is equivalent to =(rest (rest list))=)

#+BEGIN_SRC lisp
  (loop for rest on '(a 2 b 2 c 3) by #'cddr
        collect rest)
  ;; ((A 2 B 2 C 3) (B 2 C 3) (C 3))
#+END_SRC

Then we add destructuring to bind only the first two items at each iteration:

#+BEGIN_SRC lisp
  (loop for (key value) on '(a 2 b 2 c 3) by #'cddr
        collect (list key (* 2 value)))
  ;; ((A 2) (B 4) (C 6))
#+END_SRC

**** Series
     :PROPERTIES:
     :CUSTOM_ID: series-16
     :END:

In general, with =destructuring-bind=:

#+BEGIN_SRC lisp
  (collect
    (mapping ((l (scan '((x 1) (y 2) (z 3)))))
      (destructuring-bind (a b) l
        (list b a))))
#+END_SRC

But for alists, =scan-alist= is provided:

#+BEGIN_SRC lisp
  (collect
    (mapping (((a b) (scan-alist '((1 . a) (2 . b) (3 . c)))))
      b))
#+END_SRC

** Iterate unique features lacking in loop
   :PROPERTIES:
   :CUSTOM_ID: iterate-unique-features-lacking-in-loop
   :END:

=iterate= has some other things unique to it.

If you are a newcomer in Lisp, it's perfectly OK to keep you this section for
later. You could very well spend your career in Lisp without resorting
to those features... although they might turn out useful one day.

*** No rigid order for clauses
    :PROPERTIES:
    :CUSTOM_ID: no-rigid-order-for-clauses
    :END:

=loop= requires that all =for= clauses appear before the loop body,
for example before a =while=. It's ok for =iter= to not follow this
order:

#+BEGIN_SRC lisp
  (iter (for x in '(1 2 99)
    (while (< x 10))
    (for y = (print x))
    (collect (list x y)))
#+END_SRC

*** Accumulating clauses can be nested
    :PROPERTIES:
    :CUSTOM_ID: accumulating-clauses-can-be-nested
    :END:

=collect=, =appending= and other accumulating clauses can appear anywhere:

#+BEGIN_SRC lisp
  (iter (for x in '(1 2 3))
    (case x
      (1 (collect :a))
      ;;  ^^ iter keyword, nested in a s-expression.
      (2 (collect :b))))
#+END_SRC

*** Finders: =finding=
    :PROPERTIES:
    :CUSTOM_ID: finders-finding
    :END:

=iterate= has [[https://common-lisp.net/project/iterate/doc/Finders.html#Finders][finders]].

#+BEGIN_QUOTE
  A finder is a clause whose value is an expression that meets some condition.
#+END_QUOTE

We can use =finding= followed by =maximizing=, =minimizing= or =such-that=.

Here's how to find the longest list in a list of lists:

#+BEGIN_SRC lisp
  (iter (for elt in '((a) (b c d) (e f)))
        (finding elt maximizing (length elt)))
  => (B C D)
#+END_SRC

The rough equivalent in LOOP would be:

#+BEGIN_SRC lisp
  (loop with max-elt = nil
        with max-key = 0
        for elt in '((a) (b c d) (e f))
        for key = (length elt)
        do
        (when (> key max-key)
          (setf max-elt elt
                max-key key))
        finally (return max-elt))
  => (B C D)
#+END_SRC

There could be more than one =such-that= clause:

#+BEGIN_SRC lisp
   (iter (for i in '(7 -4 2 -3))
         (if (plusp i)
      (finding i such-that (evenp i))
          (finding (- i) such-that (oddp i))))
  ;; => 2
#+END_SRC

We can also write =such-that #'evenp= and =such-that #'oddp=.

*** Control flow: =next-iteration=
    :PROPERTIES:
    :CUSTOM_ID: control-flow-next-iteration
    :END:

It is like "continue" and loop doesn't have it.

#+BEGIN_QUOTE
  Skips the remainder of the loop body and begins the next iteration of the loop.
#+END_QUOTE

=iterate= also has =first-iteration-p= and =(if-first-time then else)=.

See [[https://common-lisp.net/project/iterate/doc/Control-Flow.html#Control-Flow][control flow]].

*** Generators
    :PROPERTIES:
    :CUSTOM_ID: generators
    :END:

Use =generate= and =next=. A generator is lazy, it goes to the next value when said explicitly.

#+BEGIN_SRC lisp
  (iter (for i in '(1 2 3 4 5))
        (generate c in-string "black")
        (if (oddp i) (next c))
        (format t "~a " c))
  ;; b b l l a
  ;; NIL
#+END_SRC

*** Variable backtracking (=previous=) VS parallel binding
    :PROPERTIES:
    :CUSTOM_ID: variable-backtracking-previous-vs-parallel-binding
    :END:

=iterate= allows us to get the previous value of a variable:

#+BEGIN_SRC lisp
  (iter (for el in '(a b c d e))
        (for prev-el previous el)
        (collect (list el prev-el)))
  ;; => ((A NIL) (B A) (C B) (D C) (E D))
#+END_SRC

In this case however we can do it with =loop='s parallel binding =and=, which is unsupported in =iterate=:

#+BEGIN_SRC lisp
  (loop for el in '(a b c d e)
        and prev-el = nil then el
        collect (list el prev-el))
#+END_SRC

*** More clauses
    :PROPERTIES:
    :CUSTOM_ID: more-clauses
    :END:

- =in-string= can be used explicitly to iterate character by character over a string. With loop, use =across=.

#+BEGIN_SRC lisp
  (iter (for c in-string "hello")
        (collect c))
  ;; => (#\h #\e #\l #\l #\o)
#+END_SRC

- =loop= offers =collecting=, =nconcing=, and =appending=. =iterate= has these and also =adjoining=, =unioning=, =nunioning=, and =accumulating=.

#+BEGIN_SRC lisp
  (iter (for el in '(a b c a d b))
        (adjoining el))
  ;; => (A B C D)
#+END_SRC

(=adjoin= is a set operation)

- =loop= has =summing=, =counting=, =maximizing=, and =minimizing=. =iterate= also includes =multiplying= and =reducing=. reducing is the generalized reduction builder:

#+BEGIN_SRC lisp
  (iter (with dividend = 100)
        (for divisor in '(10 5 2))
        (reducing divisor by #'/ initial-value dividend))
  ;; => 1
#+END_SRC

*** Iterate is extensible
    :PROPERTIES:
    :CUSTOM_ID: iterate-is-extensible
    :END:

#+BEGIN_SRC lisp
  (defmacro dividing-by (num &keys (initial-value 0))
    `(reducing ,num by #'/ initial-value ,initial-value))

  (iter (for i in '(10 5 2))
        (dividing-by i :initial-value 100))
  => 1
#+END_SRC

but [[https://common-lisp.net/project/iterate/doc/Rolling-Your-Own.html#Rolling-Your-Own][there is more to it, see the documentation]].

We saw libraries extending =loop=, for example [[http://clsql.kpe.io/manual/loop-tuples.html][CLSQL]], but they are
full of feature flag checks (=#+(or allegro clisp-aloop cmu openmcl sbcl scl)=) and they call internal modules
(=ansi-loop::add-loop-path=, =sb-loop::add-loop-path= etc).

** Custom series scanners
   :PROPERTIES:
   :CUSTOM_ID: custom-series-scanners
   :END:

If we often scan the same type of object, we can write our own scanner
for it: the iteration itself can be factored out. Taking the example
above, of scanning a list of two-element lists, we'll write a scanner
that returns a series of the first elements and a series of the
second.

#+BEGIN_SRC lisp
  (defun scan-listlist (listlist)
    (declare (optimizable-series-function 2))
    (map-fn '(values t t)
            (lambda (l)
              (destructuring-bind (a b) l
                (values a b)))
            (scan listlist)))

  (collect
    (mapping (((a b) (scan-listlist '((x 1) (y 2) (z 3)))))
      (list b a)))
#+END_SRC

** Shorter series expressions
   :PROPERTIES:
   :CUSTOM_ID: shorter-series-expressions
   :END:

Consider this series expression:

#+BEGIN_SRC lisp

  (collect-sum (mapping ((i (scan-range :length 5)))
                      (* i 2)))
#+END_SRC

It's a bit longer than it needs to be, the =mapping= form's only
purpose is to bind the variable =i=, and =i= is used in only one
place. Series has a "hidden feature" that allows us to simplify this
expression to the following:

#+BEGIN_SRC lisp
  (collect-sum (* 2 (scan-range :length 5)))
#+END_SRC

This is called implicit mapping and can be enabled in the call to
=series::install=:

#+BEGIN_SRC lisp
  (series::install :implicit-map t)
#+END_SRC

When using implicit mapping, the =#M= reader macro demonstrated above
becomes redundant.

** Loop gotchas
   :PROPERTIES:
   :CUSTOM_ID: loop-gotchas
   :END:

- the keyword =it=, often used in functional constructs, can be
  recognized as a loop keyword. Don't use it inside a loop.

** Iterate gotchas
   :PROPERTIES:
   :CUSTOM_ID: iterate-gotchas
   :END:

It breaks on the function =count=:

#+BEGIN_SRC lisp
  (iter (for i from 1 to 10)
        (sum (count i '(1 3 5))))
#+END_SRC

It doesn't recognize the built-in =count= function and instead signals a condition.

It works in loop:

#+BEGIN_SRC lisp
  (loop for i from 1 to 10
      sum (count i '(1 3 5 99)))
  ;; 3
#+END_SRC

** Appendix: list of loop keywords
   :PROPERTIES:
   :CUSTOM_ID: appendix-list-of-loop-keywords
   :END:

*Name Clause*

#+BEGIN_EXAMPLE
  named
#+END_EXAMPLE

*Variable Clauses*

#+BEGIN_EXAMPLE
  initially finally for as with
#+END_EXAMPLE

*Main Clauses*

#+BEGIN_EXAMPLE
  do collect collecting append
  appending nconc nconcing into count
  counting sum summing maximize return loop-finish
  maximizing minimize minimizing doing
  thereis always never if when
  unless repeat while until
#+END_EXAMPLE

These don't introduce clauses:

#+BEGIN_EXAMPLE
  = and it else end from upfrom
  above below to upto downto downfrom
  in on then across being each the hash-key
  hash-keys of using hash-value hash-values
  symbol symbols present-symbol
  present-symbols external-symbol
  external-symbols fixnum float t nil of-type
#+END_EXAMPLE

But note that it's the parsing that determines what is a keyword. For example in:

#+BEGIN_SRC lisp
  (loop for key in hash-values)
#+END_SRC

Only =for= and =in= are keywords.

©Dan Robertson on [[https://stackoverflow.com/questions/52236803/list-of-loop-keywords][Stack Overflow]].

** Credit and references
   :PROPERTIES:
   :CUSTOM_ID: credit-and-references
   :END:

*** Loop
    :PROPERTIES:
    :CUSTOM_ID: loop-15
    :END:

- [[http://www.ai.sri.com/pkarp/loop.html][Tutorial for the Common Lisp Loop Macro]] by Peter D. Karp
- [[http://www.unixuser.org/~euske/doc/cl/loop.html][Common Lisp's Loop Macro Examples for Beginners]] by Yusuke Shinyama
- [[https://gitlab.com/vancan1ty/clstandard_build][Section 6.1 The LOOP Facility, of the draft Common Lisp Standard (X3J13/94-101R)]] - the (draft) standard provides background information on Loop development, specification and examples. [[https://gitlab.com/vancan1ty/clstandard_build/-/blob/master/cl-ansi-standard-draft-w-sidebar.pdf][Single PDF file available]]
- [[https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node235.html][26. Loop by Jon L White, edited and expanded by Guy L. Steele Jr.]] - from the book "Common Lisp the Language, 2nd Edition". Strong connection to the draft above, with supplementing comments and examples.

*** Iterate
    :PROPERTIES:
    :CUSTOM_ID: iterate-3
    :END:

- [[https://common-lisp.net/project/iterate/doc/index.org][The Iterate Manual]] -by Jonathan Amsterdam and Luís Oliveira
- [[https://common-lisp-libraries.readthedocs.io/iterate/][iterate - Pseudocodic Iteration]] - by Shubhamkar Ayare
- [[https://sites.google.com/site/sabraonthehill/loop-v-iter][Loop v Iterate - SabraOnTheHill]]
- [[https://web.archive.org/web/20170713081006/https://items.sjbach.com/211/comparing-loop-and-iterate][Comparing loop and iterate]] - by Stephen Bach (web archive)

*** Series
    :PROPERTIES:
    :CUSTOM_ID: series-17
    :END:

- [[https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node347.html][Common Lisp the Language (2nd Edition) - Appendix A. Series]]
- [[http://series.sourceforge.net/][SERIES for Common Lisp - Richard C. Waters]]

*** Others
    :PROPERTIES:
    :CUSTOM_ID: others
    :END:

- See also: [[https://lisp-journey.gitlab.io/blog/snippets-functional-style-more/][more functional constructs]] (do-repeat, take,...)
