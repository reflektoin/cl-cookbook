For web development as for any other task, one can leverage Common Lisp's
advantages: the unmatched REPL that even helps to interact with a running web
app, the exception handling system, performance, the ability to build a
self-contained executable, stability, good threads story, strong typing, etc. We
can, say, define a new route and try it right away, there is no need to restart
any running server. We can change and compile /one function at a time/ (the
usual =C-c C-c= in Slime) and try it. The feedback is immediate. We can choose
the degree of interactivity: the web server can catch exceptions and fire the
interactive debugger, or print lisp backtraces on the browser, or display a 404
error page and print logs on standard output. The ability to build
self-contained executables eases deployment tremendously (compared to, for
example, npm-based apps), in that we just copy the executable to a server and
run it.

And when we have deployed our app, we can still interact with it,
allowing for hot reload, that even works when new dependencies have to
be installed. If you are careful and don't want to use full live
reload, you might still enjoy this capability to reload, for example, a user's
configuration file.

We'll present here some established web frameworks and other common
libraries to help you getting started in developing a web
application. We do /not/ aim to be exhaustive nor to replace the
upstream documentation. Your feedback and contributions are
appreciated.

#+BEGIN_HTML
  <!-- form creation, form validation -->
#+END_HTML

#+BEGIN_HTML
  <!-- Javascript -->
#+END_HTML

** Overview
   :PROPERTIES:
   :CUSTOM_ID: overview
   :END:

[[https://edicl.github.io/hunchentoot][Hunchentoot]] and [[https://github.com/fukamachi/clack][Clack]] are two projects that
you'll often hear about.

Hunchentoot is

#+BEGIN_QUOTE
  a web server and at the same time a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. It provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client.
#+END_QUOTE

It is a software written by Edi Weitz ("Common Lisp Recipes",
=cl-ppcre= and [[https://edicl.github.io/][much more]]), it's used and
proven solid. One can achieve a lot with it, but sometimes with more
friction than with a traditional web framework. For example,
dispatching a route by the HTTP method is a bit convoluted, one must
write a function for the =:uri= parameter that does the check, when it
is a built-in keyword in other frameworks like Caveman.

Clack is

#+BEGIN_QUOTE
  a web application environment for Common Lisp inspired by Python's WSGI and Ruby's Rack.
#+END_QUOTE

Also written by a prolific lisper
([[https://github.com/fukamachi/][E. Fukamachi]]), it actually uses
Hunchentoot by default as the server, but thanks to its pluggable
architecture one can use another web server, like the asynchronous
[[https://github.com/fukamachi/woo][Woo]], built on the
[[http://software.schmorp.de/pkg/libev.html][libev]] event loop, maybe
"the fastest web server written in any programming language".

We'll cite also [[https://github.com/orthecreedence/wookie][Wookie]], an asynchronous HTTP server, and its
companion library
[[https://github.com/orthecreedence/cl-async][cl-async]], for general
purpose, non-blocking programming in Common Lisp, built on libuv, the
backend library in Node.js.

Clack being more recent and less documented, and Hunchentoot a
de-facto standard, we'll concentrate on the latter for this
recipe. Your contributions are of course welcome.

Web frameworks build upon web servers and can provide facilities for
common activities in web development, like a templating system, access
to a database, session management, or facilities to build a REST api.

Some web frameworks include:

- [[https://github.com/fukamachi/caveman][Caveman]], by E. Fukamachi. It provides, out of the box,
  database management, a templating engine (Djula), a project skeleton
  generator, a routing system à la Flask or Sinatra, deployment options
  (mod_lisp or FastCGI), support for Roswell on the command line, etc.
- [[https://github.com/Shirakumo/radiance][Radiance]], by [[https://github.com/Shinmera][Shinmera]]
  (Qtools, Portacle, lquery, ...), is a web application environment,
  more general than usual web frameworks. It lets us write and tie
  websites and applications together, easing their deployment as a
  whole. It has thorough [[https://shirakumo.github.io/radiance/][documentation]], a [[https://github.com/Shirakumo/radiance-tutorial][tutorial]], [[https://github.com/Shirakumo/radiance-contribs][modules]], [[https://github.com/Shirakumo?utf8=%E2%9C%93&q=radiance&type=&language=][pre-written applications]] such as [[https://github.com/Shirakumo/purplish][an image board]] or a [[https://github.com/Shirakumo/reader][blogging platform]], and more.
  For example websites, see
  [[https://shinmera.com/]],
  [[https://reader.tymoon.eu/][reader.tymoon.eu]] and [[https://events.tymoon.eu/][events.tymoon.eu]].
- [[https://github.com/joaotavora/snooze][Snooze]], by João Távora (Sly, Emacs' Yasnippet, Eglot, ...),
  is "an URL router designed around REST web services". It is
  different because in Snooze, routes are just functions and HTTP
  conditions are just Lisp conditions.
- [[https://github.com/mmontone/cl-rest-server][cl-rest-server]] is a library for writing REST web
  APIs. It features validation with schemas, annotations for logging,
  caching, permissions or authentication, documentation via OpenAPI (Swagger),
  etc.
- last but not least, [[https://github.com/40ants/weblocks][Weblocks]] is a venerable Common Lisp
  web framework that permits to write ajax-based dynamic web
  applications without writing any JavaScript, nor writing some lisp
  that would transpile to JavaScript. It is seeing an extensive
  rewrite and update since 2017. We present it in more details below.

For a full list of libraries for the web, please see the [[https://github.com/CodyReichert/awesome-cl#network-and-internet][awesome-cl
list
#network-and-internet]]
and [[https://www.cliki.net/Web][Cliki]]. If you are looking for a
featureful static site generator, see
[[https://github.com/coleslaw-org/coleslaw][Coleslaw]].

** Installation
   :PROPERTIES:
   :CUSTOM_ID: installation
   :END:

Let's install the libraries we'll use:

#+BEGIN_SRC lisp
  (ql:quickload '("hunchentoot" "caveman2" "spinneret" "djula"))
#+END_SRC

To try Weblocks, please see its documentation. The Weblocks in
Quicklisp is not yet, as of writing, the one we are interested in.

We'll start by serving local files and we'll run more than one local
server in the running image.

** Simple webserver
   :PROPERTIES:
   :CUSTOM_ID: simple-webserver
   :END:

*** Serve local files
    :PROPERTIES:
    :CUSTOM_ID: serve-local-files
    :END:

**** Hunchentoot
     :PROPERTIES:
     :CUSTOM_ID: hunchentoot
     :END:

Create and start a webserver like this:

#+BEGIN_SRC lisp
  (defvar *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242))
  (hunchentoot:start *acceptor*)
#+END_SRC

We create an instance of =easy-acceptor= on port 4242 and we start
it. We can now access [[http://127.0.0.1:4242/]]. You should get a welcome
screen with a link to the documentation and logs to the console.

By default, Hunchentoot serves the files from the =www/= directory in
its source tree. Thus, if you go to the source of
=easy-acceptor= (=M-.= in Slime), which is probably
=~/quicklisp/dists/quicklisp/software/hunchentoot-v1.2.38/=, you'll
find the =root/= directory. It contains:

- an =errors/= directory, with the error templates =404.html= and =500.html=,
- an =img/= directory,
- an =index.org= file.

To serve another directory, we give the option =document-root= to
=easy-acceptor=. We can also set the slot with its accessor:

#+BEGIN_SRC lisp
  (setf (hunchentoot:acceptor-document-root *acceptor*) #p"path/to/www")
#+END_SRC

Let's create our =index.org= first. Put this in a new
=www/index.org= at the current directory (of the lisp repl):

#+BEGIN_EXAMPLE
  <html>
    <head>
      <title>Hello!</title>
    </head>
    <body>
      <h1>Hello local server!</h1>
      <p>
      We just served our own files.
      </p>
    </body>
  </html>
#+END_EXAMPLE

Let's start a new acceptor on a new port:

#+BEGIN_SRC lisp
  (defvar *my-acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4444
                                     :document-root #p"www/"))
  (hunchentoot:start *my-acceptor*)
#+END_SRC

go to [[http://127.0.0.1:4444/]] and see the difference.

Note that we just created another /acceptor/ on a different port on
the same lisp image. This is already pretty cool.

** Access your server from the internet
   :PROPERTIES:
   :CUSTOM_ID: access-your-server-from-the-internet
   :END:

*** Hunchentoot
    :PROPERTIES:
    :CUSTOM_ID: hunchentoot-1
    :END:

With Hunchentoot we have nothing to do, we can see the server from the
internet right away.

If you evaluate this on your VPS:

#+BEGIN_EXAMPLE
  (hunchentoot:start (make-instance 'hunchentoot:easy-acceptor :port 4242))
#+END_EXAMPLE

You can see it right away on your server's IP.

Stop it with =(hunchentoot:stop *)=.

** Routing
   :PROPERTIES:
   :CUSTOM_ID: routing
   :END:

*** Simple routes
    :PROPERTIES:
    :CUSTOM_ID: simple-routes
    :END:

**** Hunchentoot
     :PROPERTIES:
     :CUSTOM_ID: hunchentoot-2
     :END:

To bind an existing function to a route, we create a "prefix dispatch"
that we push onto the =*dispatch-table*= list:

#+BEGIN_SRC lisp
  (defun hello ()
     (format nil "Hello, it works!"))

  (push
    (hunchentoot:create-prefix-dispatcher "/hello.html" #'hello)
    hunchentoot:*dispatch-table*)
#+END_SRC

To create a route with a regexp, we use =create-regex-dispatcher=, where
the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner.

If you didn't yet, create an acceptor and start the server:

#+BEGIN_SRC lisp
  (defvar *server* (make-instance 'hunchentoot:easy-acceptor :port 4242))
  (hunchentoot:start *server*)
#+END_SRC

and access it on [[http://localhost:4242/hello.html]].

We can see logs on the REPL:

#+BEGIN_EXAMPLE
  127.0.0.1 - [2018-10-27 23:50:09] "get / http/1.1" 200 393 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0"
  127.0.0.1 - [2018-10-27 23:50:10] "get /img/made-with-lisp-logo.jpg http/1.1" 200 12583 "http://localhost:4242/" "Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0"
  127.0.0.1 - [2018-10-27 23:50:10] "get /favicon.ico http/1.1" 200 1406 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0"
  127.0.0.1 - [2018-10-27 23:50:19] "get /hello.html http/1.1" 200 20 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0"
#+END_EXAMPLE

--------------

[[https://edicl.github.io/hunchentoot/#define-easy-handler][define-easy-handler]] allows to create a function and to bind it to an uri at once.

Its form follows

#+BEGIN_EXAMPLE
  define-easy-handler (function-name :uri <uri> …) (lambda list parameters)
#+END_EXAMPLE

where =<uri>= can be a string or a function.

Example:

#+BEGIN_SRC lisp
  (hunchentoot:define-easy-handler (say-yo :uri "/yo") (name)
    (setf (hunchentoot:content-type*) "text/plain")
    (format nil "Hey~@[ ~A~]!" name))
#+END_SRC

Visit it at [[http://localhost:4242/yo][p://localhost:4242/yo]] and add parameters on the url:
[[http://localhost:4242/yo?name=Alice]].

Just a thought... we didn't explicitly ask Hunchentoot to add this
route to our first acceptor of the port 4242. Let's try another acceptor (see
previous section), on port 4444: [[http://localhost:4444/yo?name=Bob]] It
works too ! In fact, =define-easy-handler= accepts an =acceptor-names=
parameter:

#+BEGIN_QUOTE
  acceptor-names (which is evaluated) can be a list of symbols which means that the handler will only be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). acceptor-names can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor.
#+END_QUOTE

So, =define-easy-handler= has the following signature:

#+BEGIN_EXAMPLE
  define-easy-handler (function-name &key uri acceptor-names default-request-type) (lambda list parameters)
#+END_EXAMPLE

It also has a =default-parameter-type= which we'll use in a minute to get url parameters.

There are also keys to know for the lambda list. Please see the documentation.

**** Easy-routes (Hunchentoot)
     :PROPERTIES:
     :CUSTOM_ID: easy-routes-hunchentoot
     :END:

[[https://github.com/mmontone/easy-routes][easy-routes]] is a route
handling extension on top of Hunchentoot. It provides:

- dispatch based on HTTP method (otherwise cumbersome in Hunchentoot)
- arguments extraction from the url path
- and decorators.

To use it, don't create a server with =hunchentoot:easy-acceptor= but
with =easy-routes:easy-routes-acceptor=:

#+BEGIN_SRC lisp
  (setf *server* (make-instance 'easy-routes:easy-routes-acceptor))
#+END_SRC

Note: there is also =routes-acceptor=. The difference is that
=easy-routes-acceptor= iterates over Hunchentoot's =*dispatch-table*=
if no route is found by =easy-routes=. That allows us, for example, to
serve static content the usual way with Hunchentoot.

Then define a route like this:

#+BEGIN_SRC lisp
  (easy-routes:defroute name ("/foo/:x" :method :get) (y &get z)
      (format nil "x: ~a y: ~a z: ~a" x y z))
#+END_SRC

Here, =:x= captures the path parameter and binds it to the =x=
variable into the route body. =y= and =&get z= define url parameters,
and we can have =&post= parameters to extract from the HTTP request
body.

These parameters can take an =:init-form= and =:parameter-type=
options as in =define-easy-handler=.

*Decorators* are functions that are executed before the route body. They
should call the =next= parameter function to continue executing the
decoration chain and the route body finally. Examples:

#+BEGIN_SRC lisp
  (defun @auth (next)
    (let ((*user* (hunchentoot:session-value 'user)))
      (if (not *user*)
      (hunchentoot:redirect "/login")
      (funcall next))))

  (defun @html (next)
    (setf (hunchentoot:content-type*) "text/html")
    (funcall next))

  (defun @json (next)
    (setf (hunchentoot:content-type*) "application/json")
    (funcall next))
  (defun @db (next)
    (postmodern:with-connection *db-spec*
      (funcall next)))
#+END_SRC

See =easy-routes=' readme for more.

**** Caveman
     :PROPERTIES:
     :CUSTOM_ID: caveman
     :END:

[[file:caveman][Caveman]] provides two ways to
define a route: the =defroute= macro and the =@route= pythonic
/annotation/:

#+BEGIN_SRC lisp
  (defroute "/welcome" (&key (|name| "Guest"))
    (format nil "Welcome, ~A" |name|))

  @route GET "/welcome"
  (lambda (&key (|name| "Guest"))
    (format nil "Welcome, ~A" |name|))
#+END_SRC

A route with an url parameter (note =:name= in the url):

#+BEGIN_SRC lisp
  (defroute "/hello/:name" (&key name)
    (format nil "Hello, ~A" name))
#+END_SRC

It is also possible to define "wildcards" parameters. It works with
the =splat= key:

#+BEGIN_SRC lisp
  (defroute "/say/*/to/*" (&key splat)
    ; matches /say/hello/to/world
    (format nil "~A" splat))
  ;=> (hello world)
#+END_SRC

We must enable regexps with =:regexp t=:

#+BEGIN_SRC lisp
  (defroute ("/hello/([\\w]+)" :regexp t) (&key captures)
    (format nil "Hello, ~A!" (first captures)))
#+END_SRC

*** Accessing GET and POST parameters
    :PROPERTIES:
    :CUSTOM_ID: accessing-get-and-post-parameters
    :END:

**** Hunchentoot
     :PROPERTIES:
     :CUSTOM_ID: hunchentoot-3
     :END:

First of all, note that we can access query parameters anytime with

#+BEGIN_SRC lisp
  (hunchentoot:parameter "my-param")
#+END_SRC

It acts on the default =*request*= object which is passed to all handlers.

There is also =get-parameter= and =post-parameter=.

Earlier we saw some key parameters to =define-easy-handler=. We now
introduce =default-parameter-type=.

We defined the following handler:

#+BEGIN_SRC lisp
  (hunchentoot:define-easy-handler (say-yo :uri "/yo") (name)
    (setf (hunchentoot:content-type*) "text/plain")
    (format nil "Hey~@[ ~A~]!" name))
#+END_SRC

The variable =name= is a string by default. Let's check it out:

#+BEGIN_SRC lisp
  (hunchentoot:define-easy-handler (say-yo :uri "/yo") (name)
    (setf (hunchentoot:content-type*) "text/plain")
    (format nil "Hey~@[ ~A~] you are of type ~a" name (type-of name)))
#+END_SRC

Going to [[http://localhost:4242/yo?name=Alice]] returns

#+BEGIN_EXAMPLE
  Hey Alice you are of type (SIMPLE-ARRAY CHARACTER (5))
#+END_EXAMPLE

To automatically bind it to another type, we use =default-parameter-type=. It can be
one of those simple types:

- ='string= (default),
- ='integer=,
- ='character= (accepting strings of length 1 only, otherwise it is nil)
- or ='boolean=

or a compound list:

- ='(:list <type>)=
- ='(:array <type>)=
- ='(:hash-table <type>)=

where =<type>= is a simple type.

#+BEGIN_HTML
  <!-- ## Sessions -->
#+END_HTML

#+BEGIN_HTML
  <!-- todo ? -->
#+END_HTML

#+BEGIN_HTML
  <!-- ## Cookies -->
#+END_HTML

** Error handling
   :PROPERTIES:
   :CUSTOM_ID: error-handling
   :END:

In all frameworks, we can choose the level of interactivity. The web
framework can return a 404 page and print output on the repl, it can
catch errors and invoke the interactive lisp debugger, or it can show
the lisp backtrace on the html page.

*** Hunchentoot
    :PROPERTIES:
    :CUSTOM_ID: hunchentoot-4
    :END:

The global variables to set to choose the error handling behaviour are:

- =*catch-errors-p*=: set to =nil= if you want errors to be caught in
  the interactive debugger (for development only, of course):

#+BEGIN_SRC lisp
  (setf hunchentoot:*catch-errors-p* nil)
#+END_SRC

See also the generic function =maybe-invoke-debugger= if you want to
fine-tune this behaviour. You might want to specialize it on specific
condition classes (see below) for debugging purposes. The default method [[http://www.lispworks.com/documentation/HyperSpec/Body/f_invoke.htm][invokes
the debugger]]
if =*catch-errors-p*= is =nil=.

- =*show-lisp-errors-p*=: set to =t= if you want to see errors in HTML output in the browser.
- =*show-lisp-backtraces-p*=: set to =nil= if the errors shown in HTML
  output (when =*show-lisp-errors-p*= is =t=) should /not/ contain
  backtrace information (defaults to =t=, shows the backtrace).

Hunchentoot defines condition classes. The superclass of all
conditions is =hunchentoot-condition=. The superclass of errors is =hunchentoot-error= (itself a subclass of =hunchentoot-condition=).

See the documentation: [[https://edicl.github.io/hunchentoot/#conditions]].

*** Clack
    :PROPERTIES:
    :CUSTOM_ID: clack
    :END:

Clack users might make a good use of plugins, like the clack-errors middleware: [[https://github.com/CodyReichert/awesome-cl#clack-plugins]].

** Weblocks - solving the "JavaScript problem"©
   :PROPERTIES:
   :CUSTOM_ID: weblocks---solving-the-javascript-problem
   :END:

[[https://github.com/40ants/weblocks][Weblocks]] is a widgets-based and
server-based framework with a built-in ajax update mechanism. It
allows to write dynamic web applications /without the need to write
JavaScript or to write lisp code that would transpile to JavaScript/.

[[file:assets/weblocks-quickstart-check-task.gif]]

Weblocks is an old framework developed by Slava Akhmechet, Stephen
Compall and Leslie Polzer. After nine calm years, it is seeing a very
active update, refactoring and rewrite effort by Alexander Artemenko.

It was initially based on continuations (they were removed to date)
and thus a lispy cousin of Smalltalk's
[[https://en.wikipedia.org/wiki/Seaside_(software)][Seaside]]. We can
also relate it to Haskell's Haste, OCaml's Eliom,
Elixir's Phoenix LiveView and others.

The [[http://ultralisp.org/][Ultralisp]] website is an example Weblocks
website in production known in the CL community.

--------------

Weblock's unit of work is the /widget/. They look like a class definition:

#+BEGIN_SRC lisp
  (defwidget task ()
     ((title
       :initarg :title
       :accessor title)
      (done
       :initarg :done
       :initform nil
       :accessor done)))
#+END_SRC

Then all we have to do is to define the =render= method for this widget:

#+BEGIN_SRC lisp
  (defmethod render ((task task))
    "Render a task."
    (with-html
          (:span (if (done task)
                     (with-html
                           (:s (title task)))
                   (title task)))))
#+END_SRC

It uses the Spinneret template engine by default, but we can bind any
other one of our choice.

To trigger an ajax event, we write lambdas in full Common Lisp:

#+BEGIN_SRC lisp
  ...
  (with-html
    (:p (:input :type "checkbox"
      :checked (done task)
      :onclick (make-js-action
                (lambda (&key &allow-other-keys)
                  (toggle task))))
  ...
#+END_SRC

The function =make-js-action= creates a simple javascript function
that calls the lisp one on the server, and automatically refreshes the
HTML of the widgets that need it. In our example, it re-renders one
task only.

Is it appealing ? Carry on this quickstart guide here: [[http://40ants.com/weblocks/quickstart.html]].

** Templates
   :PROPERTIES:
   :CUSTOM_ID: templates
   :END:

*** Djula - HTML markup
    :PROPERTIES:
    :CUSTOM_ID: djula---html-markup
    :END:

[[https://github.com/mmontone/djula][Djula]] is a port of Python's
Django template engine to Common Lisp. It has [[https://mmontone.github.io/djula/doc/build/html/index.org][excellent documentation]].

Caveman uses it by default, but otherwise it is not difficult to
setup. We must declare where our templates are with something like

#+BEGIN_SRC lisp
  (djula:add-template-directory (asdf:system-relative-pathname "webapp" "templates/"))
#+END_SRC

and then we can declare and compile the ones we use, for example::

#+BEGIN_SRC lisp
  (defparameter +base.html+ (djula:compile-template* "base.html"))
  (defparameter +welcome.html+ (djula:compile-template* "welcome.html"))
#+END_SRC

A Djula template looks like this (forgive the antislash in ={\%=, this
is a Jekyll limitation):

#+BEGIN_EXAMPLE
  {\% extends "base.html" \%}
  {\% block title %}Memberlist{\% endblock \%}
  {\% block content \%}
    <ul>
    {\% for user in users \%}
      <li><a href="{{ user.url }}">{{ user.username }}</a></li>
    {\% endfor \%}
    </ul>
  {\% endblock \%}
#+END_EXAMPLE

At last, to render the template, call =djula:render-template*= inside a route.

#+BEGIN_SRC lisp
  (easy-routes:defroute root ("/" :method :get) ()
    (djula:render-template* +welcome.html+ nil
                            :users (get-users)
#+END_SRC

Note that for efficiency Djula compiles the templates before rendering them.

It is, along with its companion
[[https://github.com/AccelerationNet/access/][access]] library, one of
the most downloaded libraries of Quicklisp.

**** Djula filters
     :PROPERTIES:
     :CUSTOM_ID: djula-filters
     :END:

Filters allow to modify how a variable is displayed. Djula comes with
a good set of built-in filters and they are [[https://mmontone.github.io/djula/doc/build/html/filters.html][well documented]]. They are not to be confused with [[https://mmontone.github.io/djula/doc/build/html/tags.html][tags]].

They look like this: ={{ name | lower }}=, where =lower= is an
existing filter, which renders the text into lowercase.

Filters sometimes take arguments. For example: ={{ value | add:2 }}= calls
the =add= filter with arguments =value= and 2.

Moreover, it is very easy to define custom filters. All we have to do
is to use the =def-filter= macro, which takes the variable as first
argument, and which can take more optional arguments.

Its general form is:

#+BEGIN_SRC lisp
  (def-filter :myfilter-name (value arg) ;; arg is optional
     (body))
#+END_SRC

and it is used like this: ={{ value | myfilter-name }}=.

Here's how the =add= filter is defined:

#+BEGIN_SRC lisp
  (def-filter :add (it n)
    (+ it (parse-integer n)))
#+END_SRC

Once you have written a custom filter, you can use it right away
throughout the application.

Filters are very handy to move non-trivial formatting or logic from the
templates to the backend.

*** Spinneret - lispy templates
    :PROPERTIES:
    :CUSTOM_ID: spinneret---lispy-templates
    :END:

[[https://github.com/ruricolist/spinneret][Spinneret]] is a "lispy"
HTML5 generator. It looks like this:

#+BEGIN_SRC lisp
  (with-page (:title "Home page")
    (:header
     (:h1 "Home page"))
    (:section
     ("~A, here is *your* shopping list: " *user-name*)
     (:ol (dolist (item *shopping-list*)
            (:li (1+ (random 10)) item))))
    (:footer ("Last login: ~A" *last-login*)))
#+END_SRC

The author finds it is easier to compose the HTML in separate
functions and macros than with the more famous cl-who. But it
has more features under it sleeves:

- it warns on invalid tags and attributes
- it can automatically number headers, given their depth
- it pretty prints html per default, with control over line breaks
- it understands embedded markdown
- it can tell where in the document a generator function is (see =get-html-tag=)

** Serve static assets
   :PROPERTIES:
   :CUSTOM_ID: serve-static-assets
   :END:

*** Hunchentoot
    :PROPERTIES:
    :CUSTOM_ID: hunchentoot-5
    :END:

With Hunchentoot, use =create-folder-dispatcher-and-handler prefix directory=.

For example:

#+BEGIN_SRC lisp
  (push (hunchentoot:create-folder-dispatcher-and-handler
         "/static/" (merge-pathnames "src/static"  ;; starts without a /
                                     (asdf:system-source-directory :myproject)))
        hunchentoot:*dispatch-table*)
#+END_SRC

Now our project's static files located under
=/path/to/myproject/src/static/= are served with the =/static/= prefix:

#+BEGIN_EXAMPLE
  <img src="/static/img/banner.jpg" />
#+END_EXAMPLE

** Connecting to a database
   :PROPERTIES:
   :CUSTOM_ID: connecting-to-a-database
   :END:

Please see the [[file:databases.org][databases section]]. The Mito ORM
supports SQLite3, PostgreSQL, MySQL, it has migrations and db schema
versioning, etc.

In Caveman, a database connection is alive during the Lisp session and is
reused in each HTTP requests.

*** Checking a user is logged-in
    :PROPERTIES:
    :CUSTOM_ID: checking-a-user-is-logged-in
    :END:

A framework will provide a way to work with sessions. We'll create a
little macro to wrap our routes to check if the user is logged in.

In Caveman, =*session*= is a hash table that represents the session's
data. Here are our login and logout functions:

#+BEGIN_SRC lisp
  (defun login (user)
    "Log the user into the session"
    (setf (gethash :user *session*) user))

  (defun logout ()
    "Log the user out of the session."
    (setf (gethash :user *session*) nil))
#+END_SRC

We define a simple predicate:

#+BEGIN_SRC lisp
  (defun logged-in-p ()
    (gethash :user cm:*session*))
#+END_SRC

and we define our =with-logged-in= macro:

#+BEGIN_SRC lisp
  (defmacro with-logged-in (&body body)
    `(if (logged-in-p)
         (progn ,@body)
         (render #p"login.html"
                 '(:message "Please log-in to access this page."))))
#+END_SRC

If the user isn't logged in, there will nothing in the session store,
and we render the login page. When all is well, we execute the macro's
body. We use it like this:

#+BEGIN_SRC lisp
  (defroute "/account/logout" ()
    "Show the log-out page, only if the user is logged in."
    (with-logged-in
      (logout)
      (render #p"logout.html")))

  (defroute ("/account/review" :method :get) ()
    (with-logged-in
      (render #p"review.html"
              (list :review (get-review (gethash :user *session*))))))
#+END_SRC

and so on.

*** Encrypting passwords
    :PROPERTIES:
    :CUSTOM_ID: encrypting-passwords
    :END:

**** With cl-pass
     :PROPERTIES:
     :CUSTOM_ID: with-cl-pass
     :END:

[[https://github.com/eudoxia0/cl-pass][cl-pass]] is a password hashing and verification library. It is as simple to use as this:

#+BEGIN_SRC lisp
  (cl-pass:hash "test")
  ;; "PBKDF2$sha256:20000$5cf6ee792cdf05e1ba2b6325c41a5f10$19c7f2ccb3880716bf7cdf999b3ed99e07c7a8140bab37af2afdc28d8806e854"
  (cl-pass:check-password "test" *)
  ;; t
  (cl-pass:check-password "nope" **)
  ;; nil
#+END_SRC

You might also want to look at
[[https://github.com/eudoxia0/hermetic][hermetic]], a simple
authentication system for Clack-based applications.

**** Manually (with Ironclad)
     :PROPERTIES:
     :CUSTOM_ID: manually-with-ironclad
     :END:

In this recipe we do the encryption and verification ourselves. We use the de-facto standard
[[https://github.com/froydnj/ironclad][Ironclad]] cryptographic toolkit
and the [[https://github.com/cl-babel/babel][Babel]] charset
encoding/decoding library.

The following snippet creates the password hash that should be stored in your
database. Note that Ironclad expects a byte-vector, not a string.

#+BEGIN_SRC lisp
  (defun password-hash (password)
    (ironclad:pbkdf2-hash-password-to-combined-string
     (babel:string-to-octets password)))
#+END_SRC

=pbkdf2= is defined in [[https://tools.ietf.org/html/rfc2898][RFC2898]].
It uses a pseudorandom function to derive a secure encryption key
based on the password.

The following function checks if a user is active and verifies the
entered password. It returns the user-id if active and verified and
nil in all other cases even if an error occurs. Adapt it to your
application.

#+BEGIN_SRC lisp
  (defun check-user-password (user password)
    (handler-case
        (let* ((data (my-get-user-data user))
               (hash (my-get-user-hash data))
               (active (my-get-user-active data)))
          (when (and active (ironclad:pbkdf2-check-password (babel:string-to-octets password)
                                                            hash))
            (my-get-user-id data)))
      (condition () nil)))
#+END_SRC

And the following is an example on how to set the password on the
database. Note that we use =(password-hash password)= to save the
password. The rest is specific to the web framework and to the DB
library.

#+BEGIN_SRC lisp
  (defun set-password (user password)
    (with-connection (db)
      (execute
       (make-statement :update :web_user
                       (set= :hash (password-hash password))
                       (make-clause :where
                                    (make-op := (if (integerp user)
                                                    :id_user
                                                    :email)
                                             user))))))
#+END_SRC

/Credit: =/u/arvid= on [[https://www.reddit.com/r/learnlisp/comments/begcf9/can_someone_give_me_an_eli5_on_hiw_to_encrypt_and/][/r/learnlisp]]/.

** Runnning and building
   :PROPERTIES:
   :CUSTOM_ID: runnning-and-building
   :END:

*** Running the application from source
    :PROPERTIES:
    :CUSTOM_ID: running-the-application-from-source
    :END:

To run our Lisp code from source, as a script, we can use the =--load=
switch from our implementation.

We must ensure:

- to load the project's .asd system declaration (if any)
- to install the required dependencies (this demands we have installed Quicklisp previously)
- and to run our application's entry point.

We could use such commands:

#+BEGIN_SRC lisp
  ;; run.lisp

  (load "myproject.asd")

  (ql:quickload "myproject")

  (in-package :myproject)
  (handler-case
      ;; The START function starts the web server.
      (myproject::start :port (ignore-errors (parse-integer (uiop:getenv "PROJECT_PORT"))))
    (error (c)
      (format *error-output* "~&An error occured: ~a~&" c)
      (uiop:quit 1)))
#+END_SRC

In addition we have allowed the user to set the application's port
with an environment variable.

We can run the file like so:

#+BEGIN_EXAMPLE
  sbcl --load run.lisp
#+END_EXAMPLE

After loading the project, the web server is started in the
background. We are offered the usual Lisp REPL, from which we can
interact with the running application.

We can also connect to the running application from our preferred
editor, from home, and compile the changes in our editor to the
running instance. See the following section
[[#connecting-to-a-remote-lisp-image]].

*** Building a self-contained executable
    :PROPERTIES:
    :CUSTOM_ID: building-a-self-contained-executable
    :END:

As for all Common Lisp applications, we can bundle our web app in one
single executable, including the assets. It makes deployment very
easy: copy it to your server and run it.

#+BEGIN_EXAMPLE
  $ ./my-web-app
  Hunchentoot server is started.
  Listening on localhost:9003.
#+END_EXAMPLE

See this recipe on [[file:scripting.org#for-web-apps][scripting#for-web-apps]].

*** Continuous delivery with Travis CI or Gitlab CI
    :PROPERTIES:
    :CUSTOM_ID: continuous-delivery-with-travis-ci-or-gitlab-ci
    :END:

Please see the section on [[file:testing.org#continuous-integration][testing#continuous-integration]].

*** Multi-platform delivery with Electron
    :PROPERTIES:
    :CUSTOM_ID: multi-platform-delivery-with-electron
    :END:

[[https://ceramic.github.io/][Ceramic]] makes all the work for us.

It is as simple as this:

#+BEGIN_SRC lisp
  ;; Load Ceramic and our app
  (ql:quickload '(:ceramic :our-app))

  ;; Ensure Ceramic is set up
  (ceramic:setup)
  (ceramic:interactive)

  ;; Start our app (here based on the Lucerne framework)
  (lucerne:start our-app.views:app :port 8000)

  ;; Open a browser window to it
  (defvar window (ceramic:make-window :url "http://localhost:8000/"))

  ;; start Ceramic
  (ceramic:show-window window)
#+END_SRC

and we can ship this on Linux, Mac and Windows.

There is more:

#+BEGIN_QUOTE
  Ceramic applications are compiled down to native code, ensuring both performance and enabling you to deliver closed-source, commercial applications.
#+END_QUOTE

Thus, no need to minify our JS.

** Deployment
   :PROPERTIES:
   :CUSTOM_ID: deployment
   :END:

*** Deploying manually
    :PROPERTIES:
    :CUSTOM_ID: deploying-manually
    :END:

We can start our executable in a shell and send it to the background (=C-z bg=), or run it inside a =tmux= session. These are not the best but hey, it works©.

*** Daemonizing, restarting in case of crashes, handling logs with Systemd
    :PROPERTIES:
    :CUSTOM_ID: daemonizing-restarting-in-case-of-crashes-handling-logs-with-systemd
    :END:

This is actually a system-specific task. See how to do that on your system.

Most GNU/Linux distros now come with Systemd, so here's a little example.

Deploying an app with Systemd is as simple as writing a configuration file:

#+BEGIN_EXAMPLE
  $ emacs -nw /etc/systemd/system/my-app.service
  [Unit]
  Description=stupid simple example

  [Service]
  WorkingDirectory=/path/to/your/app
  ExecStart=/usr/local/bin/sthg sthg
  Type=simple
  Restart=on-failure
#+END_EXAMPLE

Then we have a command to start it:

#+BEGIN_EXAMPLE
  sudo systemctl start my-app.service
#+END_EXAMPLE

a command to check its status:

#+BEGIN_EXAMPLE
  systemctl status my-app.service
#+END_EXAMPLE

and Systemd can handle *logging* (we write to stdout or stderr, it writes logs):

#+BEGIN_EXAMPLE
  journalctl -f -u my-app.service
#+END_EXAMPLE

and it handles crashes and *restarts the app*:

#+BEGIN_EXAMPLE
  Restart=on-failure
#+END_EXAMPLE

and it can *start the app after a reboot*:

#+BEGIN_EXAMPLE
  [Install]
  WantedBy=basic.target
#+END_EXAMPLE

to enable it:

#+BEGIN_EXAMPLE
  sudo systemctl enable my-app.service
#+END_EXAMPLE

See more: [[https://www.freedesktop.org/software/systemd/man/systemd.service.html]].

*** With Docker
    :PROPERTIES:
    :CUSTOM_ID: with-docker
    :END:

There are several Docker images for Common
Lisp. For example:

- [[https://hub.docker.com/r/clfoundation/sbcl/][clfoundation/sbcl]]
  includes the latest version of SBCL, many OS packages useful for CI
  purposes, and a script to install Quicklisp.
- [[https://github.com/40ants/base-lisp-image][40ants/base-lisp-image]]
  is based on Ubuntu LTS and includes SBCL, CCL, Quicklisp, Qlot and
  Roswell.
- [[https://github.com/container-lisp/s2i-lisp][container-lisp/s2i-lisp]]
  is CentOs based and contains the source for building a Quicklisp based
  Common Lisp application as a reproducible docker image using OpenShift's
  source-to-image.

*** With Guix
    :PROPERTIES:
    :CUSTOM_ID: with-guix
    :END:

[[https://www.gnu.org/software/guix/][GNU Guix]] is a transactional
package manager, that can be installed on top of an existing OS, and a
whole distro that supports declarative system configuration. It allows
to ship self-contained tarballs, which also contain system
dependencies. For an example, see the [[https://github.com/atlas-engineer/nyxt/][Nyxt browser]].

*** Deploying on Heroku and other services
    :PROPERTIES:
    :CUSTOM_ID: deploying-on-heroku-and-other-services
    :END:

See [[https://gitlab.com/duncan-bayne/heroku-buildpack-common-lisp][heroku-buildpack-common-lisp]] and the [[https://github.com/CodyReichert/awesome-cl#deployment][Awesome CL#deploy]] section for interface libraries for Kubernetes, OpenShift, AWS, etc.

** Monitoring
   :PROPERTIES:
   :CUSTOM_ID: monitoring
   :END:

See [[https://github.com/deadtrickster/prometheus.cl][Prometheus.cl]]
for a Grafana dashboard for SBCL and Hunchentoot metrics (memory,
threads, requests per second,...).

** Connecting to a remote Lisp image
   :PROPERTIES:
   :CUSTOM_ID: connecting-to-a-remote-lisp-image
   :END:

This this section: [[file:debugging.org#remote-debugging][debugging#remote-debugging]].

** Hot reload
   :PROPERTIES:
   :CUSTOM_ID: hot-reload
   :END:

This is an example from [[https://github.com/stylewarning/quickutil/blob/master/quickutil-server/][Quickutil]]. It is actually an automated version of the precedent section.

It has a Makefile target:

#+BEGIN_SRC lisp
  hot_deploy:
      $(call $(LISP), \
          (ql:quickload :quickutil-server) (ql:quickload :swank-client), \
          (swank-client:with-slime-connection (conn "localhost" $(SWANK_PORT)) \
              (swank-client:slime-eval (quote (handler-bind ((error (function continue))) \
                  (ql:quickload :quickutil-utilities) (ql:quickload :quickutil-server) \
                  (funcall (symbol-function (intern "STOP" :quickutil-server))) \
                  (funcall (symbol-function (intern "START" :quickutil-server)) $(start_args)))) conn)) \
          $($(LISP)-quit))
#+END_SRC

It has to be run on the server (a simple fabfile command can call this
through ssh). Beforehand, a =fab update= has run =git pull= on the
server, so new code is present but not running. It connects to the
local swank server, loads the new code, stops and starts the app in a
row.

** See also
   :PROPERTIES:
   :CUSTOM_ID: see-also
   :END:

- [[https://hg.sr.ht/~wnortje/feather][Feather]], a template for web
  application development, shows a functioning Hello World app
  with an HTML page, a JSON API, a passing test suite, a Postgres DB
  and DB migrations. Uses Qlot, Buildapp, SystemD for deployment.
- [[https://github.com/vindarel/lisp-web-template-productlist][lisp-web-template-productlist]],
  a simple project template with Hunchentoot, Easy-Routes, Djula and Bulma CSS.
- [[https://github.com/vindarel/lisp-web-live-reload-example/][lisp-web-live-reload-example]] -
  a toy project to show how to interact with a running web app.

** Credits
   :PROPERTIES:
   :CUSTOM_ID: credits
   :END:

- [[https://lisp-journey.gitlab.io/web-dev/]]
