The
[[https://github.com/CodyReichert/awesome-cl#database][Database section on the Awesome-cl list]]
is a resource listing popular libraries to work with different kind of
databases. We can group them roughly in four categories:

- wrappers to one database engine (cl-sqlite, postmodern, cl-redis,...),
- interfaces to several DB engines (clsql, sxql,...),
- persistent object databases (bknr.datastore (see chap. 21 of "Common Lisp Recipes"), ubiquitous,...),
- [[https://en.wikipedia.org/wiki/Object-relational_mapping][Object Relational Mappers]] (Mito),

and other DB-related tools (pgloader).

We'll begin with an overview of Mito. If you must work with an
existing DB, you might want to have a look at cl-dbi and clsql. If you
don't need a SQL database and want automatic persistence of Lisp
objects, you also have a choice of libraries.

** The Mito ORM and SxQL
   :PROPERTIES:
   :CUSTOM_ID: the-mito-orm-and-sxql
   :END:

Mito is in Quicklisp:

#+BEGIN_SRC lisp
  (ql:quickload "mito")
#+END_SRC

*** Overview
    :PROPERTIES:
    :CUSTOM_ID: overview
    :END:

[[https://github.com/fukamachi/mito][Mito]] is "an ORM for Common Lisp
with migrations, relationships and PostgreSQL support".

- it *supports MySQL, PostgreSQL and SQLite3*,
- when defining a model, it adds an =id= (serial primary key),
  =created_at= and =updated_at= fields by default like Ruby's
  ActiveRecord or Django,
- handles DB *migrations* for the supported backends,
- permits DB *schema versioning*,
- is tested under SBCL and CCL.

As an ORM, it allows to write class definitions, to specify relationships, and
provides functions to query the database. For custom queries, it relies on
[[https://github.com/fukamachi/sxql][SxQL]], an SQL generator that provides the
same interface for several backends.

Working with Mito generally involves these steps:

- connecting to the DB
- writing [[file:clos.org][CLOS]] classes to define models
- running migrations to create or alter tables
- creating objects, saving same in the DB,

and iterating.

*** Connecting to a DB
    :PROPERTIES:
    :CUSTOM_ID: connecting-to-a-db
    :END:

Mito provides the function =connect-toplevel= to establish a
connection to RDBMs:

#+BEGIN_SRC lisp
  (mito:connect-toplevel :mysql :database-name "myapp" :username "fukamachi" :password "c0mon-1isp")
#+END_SRC

The driver type can be of =:mysql=, =:sqlite3= and =:postgres=.

With sqlite you don't need the username and password:

#+BEGIN_SRC lisp
  (mito:connect-toplevel :sqlite3 :database-name "myapp")
#+END_SRC

As usual, you need to create the MySQL or PostgreSQL database beforehand.
Refer to their documentation.

Connecting sets =mito:*connection*= to the new connection and returns it.

Disconnect with =disconnect-toplevel=.

You might make good use of a wrapper function:

#+BEGIN_SRC lisp
  (defun connect ()
    "Connect to the DB."
    (mito:connect-toplevel :sqlite3 :database-name "myapp"))
#+END_SRC

*** Models
    :PROPERTIES:
    :CUSTOM_ID: models
    :END:

**** Defining models
     :PROPERTIES:
     :CUSTOM_ID: defining-models
     :END:

In Mito, you can define a class which corresponds to a database table with the =deftable= macro:

#+BEGIN_SRC lisp
  (mito:deftable user ()
    ((name :col-type (:varchar 64))
     (email :col-type (or (:varchar 128) :null)))
#+END_SRC

Alternatively, you can specify =(:metaclass mito:dao-table-class)= in a regular class definition.

The =deftable= macro automatically adds some slots: a primary key named =id= if there's no primary key, and =created_at= and =updated_at= for recording timestamps. Specifying =(:auto-pk nil)= and =(:record-timestamps nil)= in the =deftable= form will disable these behaviours. A =deftable= class will also come with initializers, named after the slot, and accessors, of form =<class-name>-<slot-name>=, for each named slot. For example, for the =name= slot in the above table definition, the initarg =:name= will be added to the constuctor, and the accessor =user-name= will be created.

You can inspect the new class:

#+BEGIN_SRC lisp
  (mito.class:table-column-slots (find-class 'user))
  ;=> (#<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS MITO.DAO.MIXIN::ID>
  ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS COMMON-LISP-USER::NAME>
  ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS COMMON-LISP-USER::EMAIL>
  ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS MITO.DAO.MIXIN::CREATED-AT>
  ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS MITO.DAO.MIXIN::UPDATED-AT>)
#+END_SRC

The class inherits =mito:dao-class= implicitly.

#+BEGIN_SRC lisp
  (find-class 'user)
  ;=> #<MITO.DAO.TABLE:DAO-TABLE-CLASS COMMON-LISP-USER::USER>

  (c2mop:class-direct-superclasses *)
  ;=> (#<STANDARD-CLASS MITO.DAO.TABLE:DAO-CLASS>)
#+END_SRC

This may be useful when you define methods which can be applied for
all table classes.

For more information on using the Common Lisp Object System, see the
[[file:clos.org][clos]] page.

**** Creating the tables
     :PROPERTIES:
     :CUSTOM_ID: creating-the-tables
     :END:

After defining the models, you must create the tables:

#+BEGIN_SRC lisp
  (mito:ensure-table-exists 'user)
#+END_SRC

So a helper function:

#+BEGIN_SRC lisp
  (defun ensure-tables ()
    (mapcar #'mito:ensure-table-exists '(user foo bar)))
#+END_SRC

See
[[https://github.com/fukamachi/mito#generating-table-definitions][Mito's documentation]]
for a couple more ways.

When you alter the model you'll need to run a DB migration, see the next section.

**** Fields
     :PROPERTIES:
     :CUSTOM_ID: fields
     :END:

***** Fields types
      :PROPERTIES:
      :CUSTOM_ID: fields-types
      :END:

Field types are:

=(:varchar <integer>)= ,

=:serial=, =:bigserial=, =:integer=, =:bigint=, =:unsigned=,

=:timestamp=, =:timestamptz=,

=:bytea=,

***** Optional fields
      :PROPERTIES:
      :CUSTOM_ID: optional-fields
      :END:

Use =(or <real type> :null)=:

#+BEGIN_SRC lisp
     (email :col-type (or (:varchar 128) :null))
#+END_SRC

***** Field constraints
      :PROPERTIES:
      :CUSTOM_ID: field-constraints
      :END:

=:unique-keys= can be used like so:

#+BEGIN_SRC lisp
  (mito:deftable user ()
    ((name :col-type (:varchar 64))
     (email :col-type (:varchar 128))
    (:unique-keys email))
#+END_SRC

We already saw =:primary-key=.

You can change the table name with =:table-name=.

**** Relationships
     :PROPERTIES:
     :CUSTOM_ID: relationships
     :END:

You can define a relationship by specifying a foreign class with =:col-type=:

#+BEGIN_SRC lisp
  (mito:deftable tweet ()
    ((status :col-type :text)
     ;; This slot refers to USER class
     (user :col-type user))

  (table-definition (find-class 'tweet))
  ;=> (#<SXQL-STATEMENT: CREATE TABLE tweet (
  ;        id BIGSERIAL NOT NULL PRIMARY KEY,
  ;        status TEXT NOT NULL,
  ;        user_id BIGINT NOT NULL,
  ;        created_at TIMESTAMP,
  ;        updated_at TIMESTAMP
  ;    )>)
#+END_SRC

Now you can create or retrieve a =TWEET= by a =USER= object, not a =USER-ID=.

#+BEGIN_SRC lisp
  (defvar *user* (mito:create-dao 'user :name "Eitaro Fukamachi"))
  (mito:create-dao 'tweet :user *user*)

  (mito:find-dao 'tweet :user *user*)
#+END_SRC

Mito doesn't add foreign key constraints for referring tables.

***** One-to-one
      :PROPERTIES:
      :CUSTOM_ID: one-to-one
      :END:

A one-to-one relationship is simply represented with a simple foreign
key on a slot (as =:col-type user= in the =tweet= class). Besides, we
can add a unicity constraint, as with =(:unique-keys email)=.

***** One-to-many, many-to-one
      :PROPERTIES:
      :CUSTOM_ID: one-to-many-many-to-one
      :END:

The tweet example above shows a one-to-many relationship between a user and
his tweets: a user can write many tweets, and a tweet belongs to only
one user.

The relationship is defined with a foreign key on the "many" side
linking back to the "one" side. Here the =tweet= class defines a
=user= foreign key, so a tweet can only have one user. You didn't need
to edit the =user= class.

A many-to-one relationship is actually the contrary of a one-to-many.
You have to put the foreign key on the appropriate side.

***** Many-to-many
      :PROPERTIES:
      :CUSTOM_ID: many-to-many
      :END:

A many-to-many relationship needs an intermediate table, which will be
the "many" side for the two tables it is the intermediary of.

And, thanks to the join table, we can store more information about the relationship.

Let's define a =book= class:

#+BEGIN_SRC lisp
  (mito:deftable book ()
      ((title :col-type (:varchar 128))
       (ean :col-type (or (:varchar 128) :null))))
#+END_SRC

A user can have many books, and a book (as the title, not the physical
copy) is likely to be in many people's library. Here's the
intermediate class:

#+BEGIN_SRC lisp
  (mito:deftable user-books ()
      ((user :col-type user)
       (book :col-type book)))
#+END_SRC

Each time we want to add a book to a user's collection (say in
a =add-book= function), we create a new =user-books= object.

But someone may very well own many copies of one book. This is an
information we can store in the join table:

#+BEGIN_SRC lisp
  (mito:deftable user-books ()
      ((user :col-type user)
       (book :col-type book)
      ;; Set the quantity, 1 by default:
       (quantity :col-type :integer)))
#+END_SRC

**** Inheritance and mixin
     :PROPERTIES:
     :CUSTOM_ID: inheritance-and-mixin
     :END:

A subclass of DAO-CLASS is allowed to be inherited. This may be useful
when you need classes which have similar columns:

#+BEGIN_SRC lisp
  (mito:deftable user ()
    ((name :col-type (:varchar 64))
     (email :col-type (:varchar 128)))
    (:unique-keys email))

  (mito:deftable temporary-user (user)
    ((registered-at :col-type :timestamp)))

  (mito:table-definition 'temporary-user)
  ;=> (#<SXQL-STATEMENT: CREATE TABLE temporary_user (
  ;        id BIGSERIAL NOT NULL PRIMARY KEY,
  ;        name VARCHAR(64) NOT NULL,
  ;        email VARCHAR(128) NOT NULL,
  ;        registered_at TIMESTAMP NOT NULL,
  ;        created_at TIMESTAMP,
  ;        updated_at TIMESTAMP,
  ;        UNIQUE (email)
  ;    )>)
#+END_SRC

If you need a 'template' for tables which aren't related to any
database tables, you can use =DAO-TABLE-MIXIN= in a =defclass= form. The =has-email=
class below will not create a table.

#+BEGIN_SRC lisp
  (defclass has-email ()
    ((email :col-type (:varchar 128)
            :initarg :email
            :accessor object-email))
    (:metaclass mito:dao-table-mixin)
    (:unique-keys email))
  ;=> #<MITO.DAO.MIXIN:DAO-TABLE-MIXIN COMMON-LISP-USER::HAS-EMAIL>

  (mito:deftable user (has-email)
    ((name :col-type (:varchar 64))))
  ;=> #<MITO.DAO.TABLE:DAO-TABLE-CLASS COMMON-LISP-USER::USER>

  (mito:table-definition 'user)
  ;=> (#<SXQL-STATEMENT: CREATE TABLE user (
  ;       id BIGSERIAL NOT NULL PRIMARY KEY,
  ;       name VARCHAR(64) NOT NULL,
  ;       email VARCHAR(128) NOT NULL,
  ;       created_at TIMESTAMP,
  ;       updated_at TIMESTAMP,
  ;       UNIQUE (email)
  ;   )>)
#+END_SRC

See more examples of use in [[https://github.com/fukamachi/mito-auth/][mito-auth]].

**** Troubleshooting
     :PROPERTIES:
     :CUSTOM_ID: troubleshooting
     :END:

***** "Cannot CHANGE-CLASS objects into CLASS metaobjects."
      :PROPERTIES:
      :CUSTOM_ID: cannot-change-class-objects-into-class-metaobjects.
      :END:

If you get the following error message:

#+BEGIN_EXAMPLE
  Cannot CHANGE-CLASS objects into CLASS metaobjects.
     [Condition of type SB-PCL::METAOBJECT-INITIALIZATION-VIOLATION]
  See also:
    The Art of the Metaobject Protocol, CLASS [:initialization]
#+END_EXAMPLE

it is certainly because you first wrote a class definition and /then/
added the Mito metaclass and tried to evaluate the class definition
again.

If this happens, you must remove the class definition from the current package:

#+BEGIN_SRC lisp
  (setf (find-class 'foo) nil)
#+END_SRC

or, with the Slime inspector, click on the class and find the "remove" button.

More info [[https://stackoverflow.com/questions/38811931/how-to-change-classs-metaclass][here]].

*** Migrations
    :PROPERTIES:
    :CUSTOM_ID: migrations
    :END:

We can run database migrations manually, as shown below, or we can
automatically run migrations after a change to the model
definitions. To enable automatic migrations, set =mito:*auto-migration-mode*= to =t=.

The first step is to create the tables, if needed:

#+BEGIN_SRC lisp
  (ensure-table-exists 'user)
#+END_SRC

then alter the tables:

#+BEGIN_SRC lisp
  (mito:migrate-table 'user)
#+END_SRC

You can check the SQL generated code with =migration-expressions 'class=. For example, we create the =user= table:

#+BEGIN_SRC lisp
  (ensure-table-exists 'user)
  ;-> ;; CREATE TABLE IF NOT EXISTS "user" (
  ;       "id" BIGSERIAL NOT NULL PRIMARY KEY,
  ;       "name" VARCHAR(64) NOT NULL,
  ;       "email" VARCHAR(128),
  ;       "created_at" TIMESTAMP,
  ;       "updated_at" TIMESTAMP
  ;   ) () [0 rows] | MITO.DAO:ENSURE-TABLE-EXISTS
#+END_SRC

There are no changes from the previous user definition:

#+BEGIN_SRC lisp
  (mito:migration-expressions 'user)
  ;=> NIL
#+END_SRC

Now let's add a unique =email= field:

#+BEGIN_SRC lisp
  (mito:deftable user ()
    ((name :col-type (:varchar 64))
     (email :col-type (:varchar 128)))
    (:unique-keys email))
#+END_SRC

The migration will run the following code:

#+BEGIN_SRC lisp
  (mito:migration-expressions 'user)
  ;=> (#<SXQL-STATEMENT: ALTER TABLE user ALTER COLUMN email TYPE character varying(128), ALTER COLUMN email SET NOT NULL>
  ;    #<SXQL-STATEMENT: CREATE UNIQUE INDEX unique_user_email ON user (email)>)
#+END_SRC

so let's apply it:

#+BEGIN_SRC lisp
  (mito:migrate-table 'user)
  ;-> ;; ALTER TABLE "user" ALTER COLUMN "email" TYPE character varying(128), ALTER COLUMN "email" SET NOT NULL () [0 rows] | MITO.MIGRATION.TABLE:MIGRATE-TABLE
  ;   ;; CREATE UNIQUE INDEX "unique_user_email" ON "user" ("email") () [0 rows] | MITO.MIGRATION.TABLE:MIGRATE-TABLE
  ;-> (#<SXQL-STATEMENT: ALTER TABLE user ALTER COLUMN email TYPE character varying(128), ALTER COLUMN email SET NOT NULL>
  ;    #<SXQL-STATEMENT: CREATE UNIQUE INDEX unique_user_email ON user (email)>)
#+END_SRC

*** Queries
    :PROPERTIES:
    :CUSTOM_ID: queries
    :END:

**** Creating objects
     :PROPERTIES:
     :CUSTOM_ID: creating-objects
     :END:

We can create user objects with the regular =make-instance=:

#+BEGIN_SRC lisp
  (defvar me
    (make-instance 'user :name "Eitaro Fukamachi" :email "e.arrows@gmail.com"))
  ;=> USER
#+END_SRC

To save it in DB, use =insert-dao=:

#+BEGIN_SRC lisp
  (mito:insert-dao me)
  ;-> ;; INSERT INTO `user` (`name`, `email`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?) ("Eitaro Fukamachi", "e.arrows@gmail.com", "2016-02-04T19:55:16.365543Z", "2016-02-04T19:55:16.365543Z") [0 rows] | MITO.DAO:INSERT-DAO
  ;=> #<USER {10053C4453}>
#+END_SRC

Do the two steps above at once:

#+BEGIN_SRC lisp
  (mito:create-dao 'user :name "Eitaro Fukamachi" :email "e.arrows@gmail.com")
#+END_SRC

You should not export the =user= class and create objects outside of
its package (it is good practice anyway to keep all database-related
operations in say a =models= package and file). You should instead use
a helper function:

#+BEGIN_SRC lisp
  (defun make-user (&key name)
    (make-instance 'user :name name))
#+END_SRC

**** Updating fields
     :PROPERTIES:
     :CUSTOM_ID: updating-fields
     :END:

#+BEGIN_SRC lisp
  (setf (slot-value me 'name) "nitro_idiot")
  ;=> "nitro_idiot"
#+END_SRC

and save it:

#+BEGIN_SRC lisp
  (mito:save-dao me)
#+END_SRC

**** Deleting
     :PROPERTIES:
     :CUSTOM_ID: deleting
     :END:

#+BEGIN_SRC lisp
  (mito:delete-dao me)
  ;-> ;; DELETE FROM `user` WHERE (`id` = ?) (1) [0 rows] | MITO.DAO:DELETE-DAO

  ;; or:
  (mito:delete-by-values 'user :id 1)
  ;-> ;; DELETE FROM `user` WHERE (`id` = ?) (1) [0 rows] | MITO.DAO:DELETE-DAO
#+END_SRC

**** Get the primary key value
     :PROPERTIES:
     :CUSTOM_ID: get-the-primary-key-value
     :END:

#+BEGIN_SRC lisp
  (mito:object-id me)
  ;=> 1
#+END_SRC

**** Count
     :PROPERTIES:
     :CUSTOM_ID: count
     :END:

#+BEGIN_SRC lisp
  (mito:count-dao 'user)
  ;=> 1
#+END_SRC

**** Find one
     :PROPERTIES:
     :CUSTOM_ID: find-one
     :END:

#+BEGIN_SRC lisp
  (mito:find-dao 'user :id 1)
  ;-> ;; SELECT * FROM `user` WHERE (`id` = ?) LIMIT 1 (1) [1 row] | MITO.DB:RETRIEVE-BY-SQL
  ;=> #<USER {10077C6073}>
#+END_SRC

So here's a possibility of generic helpers to find an object by a given key:

#+BEGIN_SRC lisp
  (defgeneric find-user (key-name key-value)
    (:documentation "Retrieves an user from the data base by one of the unique
  keys."))

  (defmethod find-user ((key-name (eql :id)) (key-value integer))
    (mito:find-dao 'user key-value))

  (defmethod find-user ((key-name (eql :name)) (key-value string))
    (first (mito:select-dao 'user
                            (sxql:where (:= :name key-value)))))
#+END_SRC

**** Find all
     :PROPERTIES:
     :CUSTOM_ID: find-all
     :END:

Use the macro =select-dao=.

Get a list of all users:

#+BEGIN_SRC lisp
  (mito:select-dao 'user)
  ;(#<USER {10077C6073}>)
  ;#<SXQL-STATEMENT: SELECT * FROM user>
#+END_SRC

**** Find by relationship
     :PROPERTIES:
     :CUSTOM_ID: find-by-relationship
     :END:

As seen above:

#+BEGIN_SRC lisp
  (mito:find-dao 'tweet :user *user*)
#+END_SRC

**** Custom queries
     :PROPERTIES:
     :CUSTOM_ID: custom-queries
     :END:

It is with =select-dao= that you can write more precise queries by
giving it [[https://github.com/fukamachi/sxql][SxQL]] statements.

Example:

#+BEGIN_SRC lisp
  (select-dao 'tweet
      (where (:like :status "%Japan%")))
#+END_SRC

another:

#+BEGIN_SRC lisp
  (select (:id :name :sex)
    (from (:as :person :p))
    (where (:and (:>= :age 18)
                 (:< :age 65)))
    (order-by (:desc :age)))
#+END_SRC

You can compose your queries with regular Lisp code:

#+BEGIN_SRC lisp
  (defun find-tweets (&key user)
    (select-dao 'tweet
      (when user
        (where (:= :user user)))
      (order-by :object-created)))
#+END_SRC

=select-dao= is a macro that expands to the right thing©.

Note: if you didn't use SXQL, then write (sxql:where ...) and (sxql:order-by ...).

You can compose your queries further with the backquote syntax.

Imagine you receive a =query= string, maybe composed of
space-separated words, and you want to search for books that have
either one of these words in their title or in their author's
name. Searching for "bob adventure" would return a book that has
"adventure" in its title and "bob" in its author name, or both in the
title.

For the example sake, an author is a string, not a link to another table:

#+BEGIN_SRC lisp
  (mito:deftable book ()
      ((title :col-type (:varchar 128))
       (author :col-type (:varchar 128))
       (ean :col-type (or (:varchar 128) :null))))
#+END_SRC

You want to add a clause that searches on both fields for each word.

#+BEGIN_SRC lisp
  (defun find-books (&key query (order :desc))
    "Return a list of books. If a query string is given, search on both the title and the author fields."
    (mito:select-dao 'book
      (when (str:non-blank-string-p query)
        (sxql:where
         `(:and
           ,@(loop for word in (str:words query)
                :collect `(:or (:like :title ,(str:concat "%" word "%"))
                               (:like :authors ,(str:concat "%" word "%")))))))
         (sxql:order-by `(,order :created-at))))
#+END_SRC

By the way, we are still using a =LIKE= statement, but with a non-small dataset you'll want to use your database's full text search engine.

**** Clauses
     :PROPERTIES:
     :CUSTOM_ID: clauses
     :END:

See the [[https://github.com/fukamachi/sxql#sql-clauses][SxQL documentation]].

Examples:

#+BEGIN_SRC lisp
  (select-dao 'foo
    (where (:and (:> :age 20) (:<= :age 65))))
#+END_SRC

#+BEGIN_SRC lisp
  (order-by :age (:desc :id))
#+END_SRC

#+BEGIN_SRC lisp
  (group-by :sex)
#+END_SRC

#+BEGIN_SRC lisp
  (having (:>= (:sum :hoge) 88))
#+END_SRC

#+BEGIN_SRC lisp
  (limit 0 10)
#+END_SRC

and =join=s, etc.

**** Operators
     :PROPERTIES:
     :CUSTOM_ID: operators
     :END:

#+BEGIN_SRC lisp
  :not
  :is-null, :not-null
  :asc, :desc
  :distinct
  :=, :!=
  :<, :>, :<= :>=
  :a<, :a>
  :as
  :in, :not-in
  :like
  :and, :or
  :+, :-, :* :/ :%
  :raw
#+END_SRC

*** Triggers
    :PROPERTIES:
    :CUSTOM_ID: triggers
    :END:

Since =insert-dao=, =update-dao= and =delete-dao= are defined as generic
functions, you can define =:before=, =:after= or =:around= methods to those, like regular [[file:clos.org#qualifiers-and-method-combination][method combination]].

#+BEGIN_SRC lisp
  (defmethod mito:insert-dao :before ((object user))
    (format t "~&Adding ~S...~%" (user-name object)))

  (mito:create-dao 'user :name "Eitaro Fukamachi" :email "e.arrows@gmail.com")
  ;-> Adding "Eitaro Fukamachi"...
  ;   ;; INSERT INTO "user" ("name", "email", "created_at", "updated_at") VALUES (?, ?, ?, ?) ("Eitaro Fukamachi", "e.arrows@gmail.com", "2016-02-16 21:13:47", "2016-02-16 21:13:47") [0 rows] | MITO.DAO:INSERT-DAO
  ;=> #<USER {100835FB33}>
#+END_SRC

*** Inflation/Deflation
    :PROPERTIES:
    :CUSTOM_ID: inflationdeflation
    :END:

Inflation/Deflation is a function to convert values between Mito and RDBMS.

#+BEGIN_SRC lisp
  (mito:deftable user-report ()
    ((title :col-type (:varchar 100))
     (body :col-type :text
           :initform "")
     (reported-at :col-type :timestamp
                  :initform (local-time:now)
                  :inflate #'local-time:universal-to-timestamp
                  :deflate #'local-time:timestamp-to-universal)))
#+END_SRC

*** Eager loading
    :PROPERTIES:
    :CUSTOM_ID: eager-loading
    :END:

One of the pains in the neck to use ORMs is the "N+1 query" problem.

#+BEGIN_SRC lisp
  ;; BAD EXAMPLE

  (use-package '(:mito :sxql))

  (defvar *tweets-contain-japan*
    (select-dao 'tweet
      (where (:like :status "%Japan%"))))

  ;; Getting names of tweeted users.
  (mapcar (lambda (tweet)
            (user-name (tweet-user tweet)))
          *tweets-contain-japan*)
#+END_SRC

This example sends a query to retrieve a user like "SELECT * FROM user
WHERE id = ?" at each iteration.

To prevent this performance issue, add =includes= to the above query
which only sends a single WHERE IN query instead of N queries:

#+BEGIN_SRC lisp
  ;; GOOD EXAMPLE with eager loading

  (use-package '(:mito :sxql))

  (defvar *tweets-contain-japan*
    (select-dao 'tweet
      (includes 'user)
      (where (:like :status "%Japan%"))))
  ;-> ;; SELECT * FROM `tweet` WHERE (`status` LIKE ?) ("%Japan%") [3 row] | MITO.DB:RETRIEVE-BY-SQL
  ;-> ;; SELECT * FROM `user` WHERE (`id` IN (?, ?, ?)) (1, 3, 12) [3 row] | MITO.DB:RETRIEVE-BY-SQL
  ;=> (#<TWEET {1003513EC3}> #<TWEET {1007BABEF3}> #<TWEET {1007BB9D63}>)

  ;; No additional SQLs will be executed.
  (tweet-user (first *))
  ;=> #<USER {100361E813}>
#+END_SRC

*** Schema versioning
    :PROPERTIES:
    :CUSTOM_ID: schema-versioning
    :END:

#+BEGIN_EXAMPLE
  $ ros install mito
  $ mito
  Usage: mito command [option...]

  Commands:
      generate-migrations
      migrate

  Options:
      -t, --type DRIVER-TYPE          DBI driver type (one of "mysql", "postgres" or "sqlite3")
      -d, --database DATABASE-NAME    Database name to use
      -u, --username USERNAME         Username for RDBMS
      -p, --password PASSWORD         Password for RDBMS
      -s, --system SYSTEM             ASDF system to load (several -s's allowed)
      -D, --directory DIRECTORY       Directory path to keep migration SQL files (default: "/Users/nitro_idiot/Programs/lib/mito/db/")
      --dry-run                       List SQL expressions to migrate
#+END_EXAMPLE

*** Introspection
    :PROPERTIES:
    :CUSTOM_ID: introspection
    :END:

Mito provides some functions for introspection.

We can access the information of *columns* with the functions in
=(mito.class.column:...)=:

- =table-column-[class, name, info, not-null-p,...]=
- =primary-key-p=

and likewise for *tables* with =(mito.class.table:...)=.

Given we get a list of slots of our class:

#+BEGIN_SRC lisp
  (ql:quickload "closer-mop")

  (closer-mop:class-direct-slots (find-class 'user))
  ;; (#<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS NAME>
  ;;  #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS EMAIL>)

  (defparameter user-slots *)
#+END_SRC

We can answer the following questions:

**** What is the type of this column ?
     :PROPERTIES:
     :CUSTOM_ID: what-is-the-type-of-this-column
     :END:

#+BEGIN_SRC lisp
  (mito.class.column:table-column-type (first user-slots))
  ;; (:VARCHAR 64)
#+END_SRC

**** Is this column nullable ?
     :PROPERTIES:
     :CUSTOM_ID: is-this-column-nullable
     :END:

#+BEGIN_SRC lisp
  (mito.class.column:table-column-not-null-p
    (first user-slots))
  ;; T
  (mito.class.column:table-column-not-null-p
    (second user-slots))
  ;; NIL
#+END_SRC

*** Testing
    :PROPERTIES:
    :CUSTOM_ID: testing
    :END:

We don't want to test DB operations against the production one. We
need to create a temporary DB before each test.

The macro below creates a temporary DB with a random name, creates the
tables, runs the code and connects back to the original DB connection.

#+BEGIN_SRC lisp
  (defpackage my-test.utils
    (:use :cl)
    (:import-from :my.models
                  :*db*
                  :*db-name*
                  :connect
                  :ensure-tables-exist
                  :migrate-all)
    (:export :with-empty-db))

  (in-package my-test.utils)

  (defun random-string (length)
    ;; thanks 40ants/hacrm.
    (let ((chars "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"))
      (coerce (loop repeat length
                    collect (aref chars (random (length chars))))
              'string)))

  (defmacro with-empty-db (&body body)
    "Run `body` with a new temporary DB."
    `(let* ((*random-state* (make-random-state t))
            (prefix (concatenate 'string
                                 (random-string 8)
                                 "/"))
            ;; Save our current DB connection.
            (connection mito:*connection*))
       (uiop:with-temporary-file (:pathname name :prefix prefix)
         ;; Bind our *db-name* to a new name, so as to create a new DB.
         (let* ((*db-name* name))
           ;; Always re-connect to our real DB even in case of error in body.
           (unwind-protect
             (progn
               ;; our functions to connect to the DB, create the tables and run the migrations.
               (connect)
               (ensure-tables-exist)
               (migrate-all)
               ,@body)

             (setf mito:*connection* connection))))))
#+END_SRC

Use it like this:

#+BEGIN_SRC lisp
  (prove:subtest "Creation in a temporary DB."
    (with-empty-db
      (let ((user (make-user :name "Cookbook")))
        (save-user user)

        (prove:is (name user)
                  "Cookbook"
                  "Test username in a temp DB."))))
  ;; Creation in a temporary DB
  ;;  CREATE TABLE "user" (
  ;;       id BIGSERIAL NOT NULL PRIMARY KEY,
  ;;       name VARCHAR(64) NOT NULL,
  ;;       email VARCHAR(128) NOT NULL,
  ;;       created_at TIMESTAMP,
  ;;       updated_at TIMESTAMP,
  ;;       UNIQUE (email)
  ;; ) () [0 rows] | MITO.DB:EXECUTE-SQL
  ;; ✓ Test username in a temp DB.
#+END_SRC

** See also
   :PROPERTIES:
   :CUSTOM_ID: see-also
   :END:

- [[https://sites.google.com/site/sabraonthehill/postmodern-examples/exploring-a-database][exploring an existing (PostgreSQL) database with postmodern]]

- [[https://github.com/fukamachi/mito-attachment][mito-attachment]]

- [[https://github.com/fukamachi/mito-auth][mito-auth]]

- [[https://github.com/fukamachi/can/][can]] a role-based access right control library

- an advanced [[file:drafts/defmodel.lisp.html]["defmodel" macro]].

#+BEGIN_HTML
  <!-- # todo: Generating models for an existing DB -->
#+END_HTML
