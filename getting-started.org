We'll begin with presenting easy steps to install a development environment and to start a new Common Lisp project.

Want a 2-clicks install? Then get
[[https://shinmera.github.io/portacle/][Portacle]], /a portable and
multi-platform/ Common Lisp environment. It ships Emacs, SBCL (the
implementation), Quicklisp (package manager), SLIME (IDE) and
Git. It's the most straightforward way to get going!

** Install an implementation
   :PROPERTIES:
   :CUSTOM_ID: install-an-implementation
   :END:

*** With your package manager
    :PROPERTIES:
    :CUSTOM_ID: with-your-package-manager
    :END:

If you don't know which implementation of Common Lisp to use, try SBCL:

#+BEGIN_EXAMPLE
  apt-get install sbcl
#+END_EXAMPLE

Common Lisp has been standardized via an ANSI document, so it can be
implemented in different ways. See
[[https://en.wikipedia.org/wiki/Common_Lisp#Implementations][Wikipedia's list of implementations]].

The following implementations are packaged for Debian and most other popular Linux distributions:

- [[http://www.sbcl.org/][Steel Bank Common Lisp (SBCL)]]
- [[https://gitlab.com/embeddable-common-lisp/ecl/][Embeddable Common Lisp (ECL)]], which compiles to C,
- [[https://clisp.sourceforge.io/][CLISP]]

Other well-known implementations include:

- [[http://abcl.org/][ABCL]], to interface with the JVM,
- [[https://ccl.clozure.com/][ClozureCL]], a good implementation with very fast build times (see this [[http://mr.gy/blog/clozure-cl-deb.html][Debian package for Clozure CL]]),
- [[https://github.com/drmeister/clasp][CLASP]], that interoperates with C++ libraries using LLVM for compilation to native code,
- [[https://franz.com/products/allegrocl/][AllegroCL]] (proprietary)
- [[http://www.lispworks.com/][LispWorks]] (proprietary)

and older implementations:

- [[https://gitlab.common-lisp.net/cmucl/cmucl][CMUCL]], originally developed at Carnegie Mellon University, from which SBCL is derived, and
- [[https://en.wikipedia.org/wiki/GNU_Common_Lisp][GNU Common Lisp]]
- and there is more!

*** With the asdf-vm package manager
    :PROPERTIES:
    :CUSTOM_ID: with-the-asdf-vm-package-manager
    :END:

The [[http://asdf-vm.com/][asdf-vm]] tool can be used to manage a large ecosystem of runtimes and tools.

- [[http://www.sbcl.org/][Steel Bank Common Lisp (SBCL)]] is available via [[https://github.com/smashedtoatoms/asdf-sbcl][this plugin]] for [[http://asdf-vm.com/][asdf-vm]]

*** With Roswell
    :PROPERTIES:
    :CUSTOM_ID: with-roswell
    :END:

[[https://github.com/roswell/roswell/wiki][Roswell]] is:

- an implementation manager: it makes it easy to install a Common Lisp
  implementation (=ros install ecl=), an exact version of an
  implementation (=ros install sbcl/1.2.0=), to change the default one
  being used (=ros use ecl=),
- a scripting environment (helps to run Lisp from the shell, to get
  the command line arguments,...),
- a script installer,
- a testing environment (to run tests, including on popular Continuous
  Integration platforms),
- a building utility (to build images and executables in a portable way).

You'll find several ways of installation on its wiki (Debian package,
Windows installer, Brew/Linux Brew,...).

*** With Docker
    :PROPERTIES:
    :CUSTOM_ID: with-docker
    :END:

If you already know [[https://docs.docker.com][Docker]], you can get
started with Common Lisp pretty quickly. The
[[https://hub.docker.com/r/clfoundation/cl-devel][clfoundation/cl-devel]]
image comes with recent versions of SBCL, CCL, ECL and ABCL, plus
Quicklisp installed in the home (=/home/cl=), so than we can
=ql:quickload= libraries straight away.

Docker works on GNU/Linux, Mac and Windows.

The following command will download the required image (around 1.0GB
compressed), put your local sources inside the Docker image where indicated,
and drop you into an SBCL REPL:

#+BEGIN_EXAMPLE
  docker run --rm -it -v /path/to/local/code:/home/cl/common-lisp/source clfoundation/cl-devel:latest sbcl
#+END_EXAMPLE

We still want to develop using Emacs and SLIME, so we need to connect SLIME to
the Lisp inside Docker. See
[[https://gitlab.common-lisp.net/cl-docker-images/slime-docker][slime-docker]],
which is a library that helps on setting that up.

*** On Windows
    :PROPERTIES:
    :CUSTOM_ID: on-windows
    :END:

All implementations above can be installed on Windows.

[[https://shinmera.github.io/portacle/][Portacle]] is multiplatform and works on Windows.

You can also try:

- [[https://rho-emacs.sourceforge.io/][ρEmacs]], a preconfigured distribution of GNU Emacs specificalyl for Microsoft Windows. It ships with many CL implementations: CCL, SBCL, CLISP, ABCL and ECL, and also has components for other programming languages (Python, Racket, Java, C++...).
- [[https://github.com/sharplispers/cormanlisp][Corman Lisp]], for Windows XP, Windows 2000, Windows ME or Windows NT. It is fully integrated with the Win32 API, and all the Windows API functions are readily available from Lisp.

** Start a REPL
   :PROPERTIES:
   :CUSTOM_ID: start-a-repl
   :END:

Just launch the implementation executable on the command line to enter
the REPL (Read Eval Print Loop), i.e. the interactive
interpreter.

Quit with =(quit)= or =ctr-d= (on some implementations).

Here is a sample session:

#+BEGIN_EXAMPLE
  user@debian:~$ sbcl
  This is SBCL 1.3.14.debian, an implementation of ANSI Common Lisp.
  More information about SBCL is available at <http://www.sbcl.org/>.

  SBCL is free software, provided as is, with absolutely no warranty.
  It is mostly in the public domain; some portions are provided under
  BSD-style licenses.  See the CREDITS and COPYING files in the
  distribution for more information.
  * (+ 1 2)

  3
  * (quit)
  user@debian:~$
#+END_EXAMPLE

You can slightly enhance the REPL (the arrow keys do not work,
it has no history,...) with =rlwrap=:

#+BEGIN_EXAMPLE
  apt-get install rlwrap
#+END_EXAMPLE

and:

#+BEGIN_EXAMPLE
  rlwrap sbcl
#+END_EXAMPLE

But we'll setup our editor to offer a better experience instead of
working in this REPL. See [[file:editor-support.org][editor-support]].

Lisp is interactive by nature, so in case of an error we enter the
debugger. This can be annoying in certain cases, so you might want to
use SBCL's =--disable-debugger= option.

#+BEGIN_HTML
  <!-- if inside a <p> then bootstrap adds 10px padding to the bottom -->
#+END_HTML

TIP: The CLISP implementation has a better default REPL for the
terminal (readline capabilities, completion of symbols). You can even
use clisp -on-error abort to have error messages without the
debugger. It's handy to try things out, but we recommend to set-up
your editor and to use SBCL or CCL.

** Libraries
   :PROPERTIES:
   :CUSTOM_ID: libraries
   :END:

Common Lisp has thousands of libraries available under a free software license. See:

- [[http://quickdocs.org/][Quickdocs]] - the library documentation hosting for CL.
- the [[https://github.com/CodyReichert/awesome-cl][Awesome-cl]] list, a
  curated list of libraries.
- [[http://www.cliki.net/][Cliki]], the Common Lisp wiki.

*** Some terminology
    :PROPERTIES:
    :CUSTOM_ID: some-terminology
    :END:

- In the Common Lisp world, a *package* is a way of grouping symbols
  together and of providing encapsulation. It is similar to a C++
  namespace, a Python module or a Java package.

- A *system* is a collection of CL source files bundled with an .asd
  file which tells how to compile and load them. There is often a
  one-to-one relationship between systems and packages, but this is in
  no way mandatory. A system may declare a dependency on other
  systems. Systems are managed by [[https://common-lisp.net/project/asdf/asdf.html][ASDF]] (Another System Definition
  Facility), which offers functionalities similar to those of =make= and
  =ld.so=, and has become a de facto standard.

- A Common Lisp library or project typically consists of one or
  several ASDF systems (and is distributed as one Quicklisp project).

*** Install Quicklisp
    :PROPERTIES:
    :CUSTOM_ID: install-quicklisp
    :END:

[[https://www.quicklisp.org/beta/][Quicklisp]] is more than a package
manager, it is also a central repository (a /dist/) that ensures that
all libraries build together.

It provides its own /dist/ but it is also possible to build our own.

To install it, we can either:

1- run this command, anywhere:

#+BEGIN_EXAMPLE
  curl -O https://beta.quicklisp.org/quicklisp.lisp
#+END_EXAMPLE

and enter a Lisp REPL and load this file:

#+BEGIN_EXAMPLE
  sbcl --load quicklisp.lisp
#+END_EXAMPLE

or

2- install the Debian package:

#+BEGIN_EXAMPLE
  apt-get install cl-quicklisp
#+END_EXAMPLE

and load it, from a REPL:

#+BEGIN_SRC lisp
  (load "/usr/share/common-lisp/source/quicklisp/quicklisp.lisp")
#+END_SRC

Then, in both cases, still from the REPL:

#+BEGIN_SRC lisp
  (quicklisp-quickstart:install)
#+END_SRC

This will create the =~/quicklisp/= directory, where Quicklisp will
maintain its state and downloaded projects.

If you wish, you can install Quicklisp to a different location. For instance,
to install it to a hidden folder on Unix systems:

#+BEGIN_SRC lisp
  (quicklisp-quickstart:install :path "~/.quicklisp")
#+END_SRC

If you want Quicklisp to always be loaded in your Lisp sessions, run
=(ql:add-to-init-file)=: this adds the right stuff to the init file of
your CL implementation. Otherwise, you have to run =(load "~/quicklisp/setup.lisp")= in every session if you want to use
Quicklisp or any of the libraries installed through it.

It adds the following in your (for example) =~/.sbclrc=:

#+BEGIN_SRC lisp
  #-quicklisp
    (let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp"
                                           (user-homedir-pathname))))
      (when (probe-file quicklisp-init)
        (load quicklisp-init)))
#+END_SRC

*** Install libraries
    :PROPERTIES:
    :CUSTOM_ID: install-libraries
    :END:

In the REPL:

#+BEGIN_SRC lisp
  (ql:quickload "package-name")
#+END_SRC

and voilà. See Quicklisp's documentation for more commands.

Note also that dozens of Common Lisp libraries are packaged in
Debian. The package names usually begin with the cl- prefix (use
=apt-cache search --names-only "^cl-.*"= to list them all).

For example, in order to use the CL-PPCRE library (for regular
expressions), one should first install the =cl-ppcre= package.

Then, in SBCL and ECL, it can be used with:

#+BEGIN_SRC lisp
  (require "asdf")
  (require "cl-ppcre")
  (cl-ppcre:regex-replace "fo+" "foo bar" "frob")
#+END_SRC

See more: https://wiki.debian.org/CommonLisp

*** Advanced dependencies management
    :PROPERTIES:
    :CUSTOM_ID: advanced-dependencies-management
    :END:

You can drop Common Lisp projects into any of those folders:

- =~/common-lisp=,
- =~/.local/share/common-lisp/source=,
- =~/quicklisp/local-projects=

For a complete list, see

#+BEGIN_SRC lisp
  (asdf/source-registry:default-user-source-registry)
#+END_SRC

and

#+BEGIN_SRC lisp
  asdf:*central-registry*
#+END_SRC

A library installed here is automatically available for every project.

**** Providing our own version of a library. Cloning projects.
     :PROPERTIES:
     :CUSTOM_ID: providing-our-own-version-of-a-library.-cloning-projects.
     :END:

Given the property above, we can clone any library into the
local-projects directory and it will be found by ASDF (and Quicklisp) and
available right-away:

#+BEGIN_SRC lisp
  (asdf:load-system "system")
#+END_SRC

or

#+BEGIN_SRC lisp
  (ql:quickload "system")
#+END_SRC

The practical different between the two is that =ql:quickload= first tries to
fetch the system from the Internet if it is not already installed.

**** How to work with local versions of libraries
     :PROPERTIES:
     :CUSTOM_ID: how-to-work-with-local-versions-of-libraries
     :END:

If we need libraries to be installed locally, for only one project, or
in order to easily ship a list of dependencies with an application, we
can use [[https://github.com/fukamachi/qlot][Qlot]] or [[https://clpm.dev][CLPM]].

Quicklisp also provides
[[https://www.quicklisp.org/beta/bundles.html][Quicklisp bundles]]. They
are self-contained sets of systems that are exported from Quicklisp
and loadable without involving Quicklisp.

At last, there's
[[https://github.com/quicklisp/quicklisp-controller][Quicklisp controller]]
to help us build /dists/.

** Working with projects
   :PROPERTIES:
   :CUSTOM_ID: working-with-projects
   :END:

Now that we have Quicklisp and our editor ready, we can start writing
Lisp code in a file and interacting with the REPL.

But what if we want to work with an existing project or create a new
one, how do we proceed, what's the right sequence of =defpackage=,
what to put in the =.asd= file, how to load the project into the REPL ?

*** Creating a new project
    :PROPERTIES:
    :CUSTOM_ID: creating-a-new-project
    :END:

Some project builders help to scaffold the project structure. We like
[[https://github.com/fukamachi/cl-project][cl-project]] that also sets
up a tests skeleton.

In short:

#+BEGIN_SRC lisp
  (ql:quickload "cl-project")
  (cl-project:make-project #P"./path-to-project/root/")
#+END_SRC

it will create a directory structure like this:

#+BEGIN_EXAMPLE
  |-- my-project.asd
  |-- my-project-test.asd
  |-- README.markdown
  |-- README.org
  |-- src
  |   `-- my-project.lisp
  `-- tests
      `-- my-project.lisp
#+END_EXAMPLE

Where =my-project.asd= resembles this:

#+BEGIN_SRC lisp
  (defsystem "my-project"
    :version "0.1.0"
    :author ""
    :license ""
    :depends-on ()  ;; <== list of Quicklisp dependencies
    :components ((:module "src"
                  :components
                  ((:file "my-project"))))
    :description ""
    :long-description
    #.(read-file-string
       (subpathname *load-pathname* "README.markdown"))
    :in-order-to ((test-op (test-op "my-project-test"))))
#+END_SRC

and =src/my-project.lisp= this:

#+BEGIN_SRC lisp
  (defpackage footest
    (:use :cl))
  (in-package :footest)
#+END_SRC

- ASDF documentation: [[https://common-lisp.net/project/asdf/asdf.html#Defining-systems-with-defsystem][defining a system with defsystem]]

*** How to load an existing project
    :PROPERTIES:
    :CUSTOM_ID: how-to-load-an-existing-project
    :END:

You have created a new project, or you have an existing one, and you
want to work with it on the REPL, but Quicklisp doesn't know it. How
can you do ?

Well first, if you create it or clone it into
one of =~/common-lisp=, =~/.local/share/common-lisp/source/= or
=~/quicklisp/local-projects=, you'll be able to =(ql:quickload …)= it with no
further ado.

Otherwise you'll need to compile and load its system definition
(=.asd=) first. In SLIME with the =slime-asdf= contrib loaded, type =C-c C-k=
(/slime-compile-and-load-file/) in the =.asd=, then you can
=(ql:quickload …)= it.

Usually you want to "enter" the system in the REPL at this stage:

#+BEGIN_SRC lisp
  (in-package :my-project)
#+END_SRC

Lastly, you can compile or eval the sources (=my-project.lisp=) with
=C-c C-k= or =C-c C-c= (/slime-compile-defun/) in a form, and see its
result in the REPL.

Another solution is to use ASDF's list of known projects:

#+BEGIN_SRC lisp
  (pushnew "~/path-to-project/root/" asdf:*central-registry* :test #'equal)
#+END_SRC

and since ASDF is integrated into Quicklisp, we can =quickload= our project.

Happy hacking !

** More settings
   :PROPERTIES:
   :CUSTOM_ID: more-settings
   :END:

You might want to set SBCL's default encoding format to utf-8:

#+BEGIN_EXAMPLE
  (setf sb-impl::*default-external-format* :utf-8)
#+END_EXAMPLE

You can add this to your =~/.sbclrc=.

If you dislike the REPL to print all symbols upcase, add this:

#+BEGIN_EXAMPLE
  (setf *print-case* :downcase)
#+END_EXAMPLE

#+BEGIN_HTML
  <!-- if inside a <p> then bootstrap adds 10px padding to the bottom -->
#+END_HTML

Warning: This might break the behaviour of some packages like it happened with
Mito.
Avoid doing this in production.

** Read more
   :PROPERTIES:
   :CUSTOM_ID: read-more
   :END:

- Source code organization, libraries and packages: [[https://lispmethods.com/libraries.html]]

** Credits
   :PROPERTIES:
   :CUSTOM_ID: credits
   :END:

- [[https://wiki.debian.org/CommonLisp]]
- [[http://articulate-lisp.com/project/new-project.html]]
